pubspec.yaml:
name: krono
description: "A daily photo journal app to track your year, one moment at a time"
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: '>=3.5.0 <4.0.0' # Setați pe versiunea actuală de Flutter

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter

  # UI & UX
  flutter_speed_dial: ^7.0.0
  gap: ^3.0.1
  cupertino_icons: ^1.0.8
  google_fonts: ^6.1.0
  table_calendar: ^3.0.9
  url_launcher: ^6.3.2

  # State Management
  flutter_riverpod: ^3.1.0

  # Media & Files
  gal: ^2.1.1
  image_picker: ^1.0.4
  file_picker: ^10.3.8
  path_provider: ^2.1.2
  path: ^1.9.0
  archive: ^4.0.7
  image: ^4.5.4

  # Database (Drift)
  drift: ^2.20.0
  drift_flutter: ^0.2.0
  sqlite3_flutter_libs: ^0.5.24

  # System & Auth
  local_auth: ^3.0.0
  shared_preferences: ^2.5.4
  share_plus: ^12.0.1

  # Notifications & Background
  flutter_local_notifications: ^19.5.0
  flutter_timezone: ^5.0.1
  timezone: ^0.10.1

  # Utils & Exports
  intl: ^0.20.2
  http: ^1.6.0
  pdf: ^3.10.8
  printing: ^5.11.1
  flutter_image_compress: ^2.4.0
  geolocator: ^14.0.2
  geocoding: ^4.0.0
  marquee: ^2.3.0
  permission_handler: ^12.0.1
  camera: 0.11.3
  perfect_volume_control: ^1.0.6
  flutter_native_splash: "^2.4.0"
  visibility_detector: ^0.4.0+2
  flutter_quill: ^11.5.0
  crypto: ^3.0.7
  sliver_tools: ^0.2.12
  fps_monitor: ^2.0.0
  photo_manager: ^3.8.3

  # Firebase
  firebase_core: ^4.4.0
  firebase_auth: ^6.1.4
  firebase_crashlytics: ^5.0.7
  firebase_analytics: ^12.1.1
  mockito: ^5.6.3
  mocktail: ^1.0.4

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

  # Generators
  build_runner: ^2.4.13
  #isar_generator: ^3.1.0+1

  drift_dev: ^2.20.0

  # Branding
  flutter_launcher_icons: ^0.14.4

  local_auth_android: any
  local_auth_darwin: any
  local_auth_windows: any
  path_provider_platform_interface: any
  plugin_platform_interface: any
  flutter_local_notifications_platform_interface: any
flutter:
  uses-material-design: true
  generate: true

  assets:
    - assets/app_icon.png
    - assets/icon_monochrome.png


flutter_launcher_icons:
  android: "ic_launcher"
  ios: true
  image_path: "assets/app_icon.png"


  adaptive_icon_background: "#121212"
  adaptive_icon_foreground: "assets/app_icon.png"

  monochrome_android_icon: "assets/icon_monochrome.png"

  notification_icon:
    path: "assets/icon_monochrome.png" # Folosim varianta monocromă (logo pe transparent)
    color: "#121212"

flutter_native_splash:
  color: "#121212"
  image: "assets/app_icon.png"
  android_12:
    image: "assets/app_icon.png"
    color: "#121212"
    icon_background_color: "#121212"
  fullscreen: true

android/app/src/main/AndroidManifest.xml:
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.RECORD_AUDIO" tools:node="remove" />

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.INTERNET" />

    <!-- Android 13+ Permissions (Granular Media) -->
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />

    <!-- Legacy Storage Permissions (Android 12 and below) -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="32" tools:replace="android:maxSdkVersion"/>

    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.USE_BIOMETRIC"/>

    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
    <uses-permission android:name="android.permission.VIBRATE" />

    <!-- NOTA: Am scos USE_EXACT_ALARM. Google respinge aplicatiile care nu sunt ceasuri desteptatoare.
         SCHEDULE_EXACT_ALARM este permis pentru remindere, dar cere justificare.
         Pentru MVP, notificările standard sunt mai sigure. -->
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />

    <!-- Hardware Features -->
    <uses-feature android:name="android.hardware.camera" android:required="false" />
    <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />

    <application
        android:label="Krono"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher"
        android:usesCleartextTraffic="false">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">

            <meta-data
                android:name="io.flutter.embedding.android.NormalTheme"
                android:resource="@style/NormalTheme"
                />

            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>

        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />

        <!-- Notification Receivers -->
        <receiver android:exported="false" android:name="com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver" />
        <receiver android:exported="false" android:name="com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <action android:name="android.intent.action.MY_PACKAGE_REPLACED"/>
                <action android:name="android.intent.action.QUICKBOOT_POWERON" />
                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON"/>
            </intent-filter>
        </receiver>

    </application>

    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
        <intent>
            <action android:name="android.intent.action.SEND" />
            <data android:mimeType="*/*" />
        </intent>
        <!-- Necesar pentru url_launcher (Privacy Policy) -->
        <intent>
            <action android:name="android.intent.action.VIEW" />
            <data android:scheme="https" />
        </intent>
    </queries>
</manifest>

android/app/build.gradle.kts:
// 1. Importurile necesare pentru a citi fișierul de proprietăți.
import java.util.Properties
import java.io.FileInputStream

plugins {
    id("com.android.application")
    id("kotlin-android")
    id("dev.flutter.flutter-gradle-plugin")
    id("com.google.gms.google-services")
    id("com.google.firebase.crashlytics")
}

// 2. Încărcăm proprietățile cheii de semnare.
val keystoreProperties = Properties()
val keystorePropertiesFile = rootProject.file("key.properties")
if (keystorePropertiesFile.exists()) {
    keystoreProperties.load(FileInputStream(keystorePropertiesFile))
}

android {
    namespace = "com.krono.app"
    compileSdk = 36
    ndkVersion = flutter.ndkVersion

    compileOptions {
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    // ✅ FIX: Revenim la blocul 'kotlinOptions'.
    // Va afișa un avertisment de depreciere, dar este sintaxa corectă
    // pentru setup-ul tău și VA COMPILA cu succes.
    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        applicationId = "com.krono.app"
        minSdk = flutter.minSdkVersion
        targetSdk = 36
        versionCode = flutter.versionCode
        versionName = flutter.versionName

        multiDexEnabled = true
    }

    // 3. Configurare Semnătură (Signing) pentru Release (Corectată)
    signingConfigs {
        create("release") {
            keyAlias = keystoreProperties.getProperty("keyAlias")
            keyPassword = keystoreProperties.getProperty("keyPassword")
            storeFile = keystoreProperties.getProperty("storeFile")?.let { path -> file(path) }
            storePassword = keystoreProperties.getProperty("storePassword")
        }
    }

    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("release")
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }

        debug {
            // ✅ FIX: Folosim cheia de release și pentru debug.
            // Asta previne dezinstalarea aplicației (și ștergerea datelor)
            // când treci de la un mod la altul.
            signingConfig = signingConfigs.getByName("release")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.4")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("androidx.multidex:multidex:2.0.1")

    // Firebase
    implementation(platform("com.google.firebase:firebase-bom:34.8.0"))
    implementation("com.google.firebase:firebase-analytics")
}

lib/src/core/bootstrap/cleanup_runner.dart:
import 'package:shared_preferences/shared_preferences.dart';

import '../database/database.dart';
import '../utils/logger_service.dart';
import '../utils/thumbnail_cleanup.dart';

/// The key used to store the last cleanup timestamp in [SharedPreferences].
const _kLastThumbCleanupKey = 'last_thumbs_cleanup_epoch';

/// Orchestrates periodic maintenance tasks for the application's filesystem.
///
/// Checks the last execution timestamp against the specified [daysThreshold] to
/// prevent redundant I/O operations on every app launch. This is a background
/// maintenance task to ensure the app remains performant.
Future<void> runCleanupIfNeeded({
  required AppDatabase db,
  required SharedPreferences prefs,
  int daysThreshold = 30,
}) async {
  try {
    final lastEpoch = prefs.getInt(_kLastThumbCleanupKey) ?? 0;
    final last = DateTime.fromMillisecondsSinceEpoch(lastEpoch);
    final now = DateTime.now();

    if (lastEpoch == 0 || now.difference(last).inDays >= daysThreshold) {
      Logger.info('Starting scheduled thumbnail cleanup...');
      await cleanupOrphanThumbnails(db);
      await prefs.setInt(_kLastThumbCleanupKey, now.millisecondsSinceEpoch);
      Logger.info('Thumbnail cleanup completed successfully.');
    }
  } catch (e, stack) {
    Logger.error('Failed to run scheduled cleanup task', e, stack);
  }
}

lib/src/core/database/models/streak_adjustment_type.dart:
/// Defines the types of manual interventions for streak calculation.
enum StreakAdjustmentType {
  /// A paid action to bridge a gap in the past.
  restore,

  /// A pre-emptive action from a premium subscription to prevent a streak from breaking.
  freeze,
}

lib/src/core/database/tables/activity_log.dart:
import 'package:drift/drift.dart';

/// Tracks dates on which the user has successfully completed an activity.
///
/// This table is used to calculate user streaks and activity history. It persists
/// a record of a completed day, even if the associated content (e.g., a photo)
/// is deleted later.
class ActivityLog extends Table {
  /// The unique identifier for the log entry.
  IntColumn get id => integer().autoIncrement()();

  /// The calendar date of the completed activity.
  ///
  /// This column has a unique constraint to ensure each date is logged only once.
  /// The time component of the [DateTime] should be ignored.
  DateTimeColumn get date => dateTime().unique()();
}

lib/src/core/database/tables/day_entries.dart:
import 'package:drift/drift.dart';

/// Schema definition for the [DayEntries] table.
///
/// This table stores all user-generated journal content, including
/// media references, emotional tracking, and environmental metadata.
@TableIndex(name: 'idx_day_entries_date', columns: {#date})
class DayEntries extends Table {
  /// Unique identifier for each entry.
  IntColumn get id => integer().autoIncrement()();

  /// The timestamp when the entry was captured.
  DateTimeColumn get date => dateTime()();

  /// Local file system path to the captured image.
  TextColumn get photoPath => text()();

  /// Local file system path to the generated thumbnail.
  TextColumn get thumbnailPath => text().nullable()();


  /// User's mood rating (typically on a scale of 1-5).
  IntColumn get moodRating => integer()();

  /// Optional text content provided by the user.
  TextColumn get note => text().nullable()();

  /// Formatted address or city name where the entry was created.
  TextColumn get location => text().nullable()();

  /// Temperature at the time of entry (e.g., "22°C").
  TextColumn get weatherTemp => text().nullable()();

  /// Identifier or URL for the weather condition icon.
  TextColumn get weatherIcon => text().nullable()();

}

lib/src/core/database/tables/streak_adjustments.dart:
import 'package:drift/drift.dart';

import '../models/streak_adjustment_type.dart';

/// Stores manual overrides for the streak logic.
///
/// This allows for "Streak Freezes" (Grace Periods) or "Paid Restores"
/// to bridge gaps between physical journal entries.
class StreakAdjustments extends Table {
  IntColumn get id => integer().autoIncrement()();

  /// The specific date being "bridged" or "frozen".
  DateTimeColumn get date => dateTime()();

  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();

  /// Type of adjustment: 'freeze' (grace period) or 'restore' (paid).
  IntColumn get type => intEnum<StreakAdjustmentType>()();
}

lib/src/core/database/database.dart:
import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'models/streak_adjustment_type.dart';
import 'tables/activity_log.dart';
import 'tables/day_entries.dart';
import 'tables/streak_adjustments.dart';

part 'database.g.dart';

/// Provides a singleton instance of the [AppDatabase] for the application.
///
/// The database connection is automatically closed when the provider is disposed.
final databaseProvider = Provider<AppDatabase>((ref) {
  final db = AppDatabase();
  ref.onDispose(() => db.close());
  return db;
});

/// The primary database engine for the Krono application.
///
/// Handles schema versioning, migrations, and provides access to all tables
/// through Data Access Objects (DAOs) generated by Drift.
@DriftDatabase(tables: [DayEntries, StreakAdjustments, ActivityLog])
class AppDatabase extends _$AppDatabase {
  /// Initializes the database with a platform-optimized connection.
  AppDatabase() : super(_openConnection());

  AppDatabase.forTesting(super.e);

  /// The current version of the database schema.
  ///
  /// This must be incremented each time the table structure is modified.
  @override
  int get schemaVersion => 5;

  /// Defines the migration strategy for handling schema changes between versions.
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (m) async {
        await m.createAll();
      },
      onUpgrade: (m, from, to) async {
        // Each "if" block handles a sequential schema upgrade.
        if (from < 2) {
          // Migration from v1 to v2: Added location and weather support.
          await m.addColumn(dayEntries, dayEntries.location);
          await m.addColumn(dayEntries, dayEntries.weatherTemp);
          await m.addColumn(dayEntries, dayEntries.weatherIcon);
        }
        if (from < 3) {
          // Migration from v2 to v3: Added thumbnail support for grid performance.
          await m.addColumn(dayEntries, dayEntries.thumbnailPath);
        }
        if (from < 4) {
          // Migration from v3 to v4: Added streak adjustments for monetization/restores.
          await m.createTable(streakAdjustments);
        }
        if (from < 5) {
          // Migration from v4 to v5: Added a dedicated log for completed activities.
          await m.createTable(activityLog);
        }
      },
      beforeOpen: (details) async {
        // This callback is executed before any queries are sent.
        // Useful for enabling features like foreign keys if needed.
      },
    );
  }

  /// Creates the platform-specific database connection.
  static QueryExecutor _openConnection() {
    return driftDatabase(
      name: 'krono_database',
      native: const DriftNativeOptions(
        // Allows the database connection to be used across different isolates,
        // which is beneficial for background processing.
        shareAcrossIsolates: true,
      ),
    );
  }
}

lib/src/core/providers/auth_provider.dart:
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:local_auth/local_auth.dart';

import '../utils/auth_service.dart';
import 'theme_provider.dart';

/// Provides a singleton instance of the [LocalAuthentication] plugin.
///
/// This is the low-level service used to interact with the device's
/// biometric hardware (e.g., fingerprint or face ID).
final localAuthProvider =
Provider<LocalAuthentication>((ref) => LocalAuthentication());

/// Provides the application's authentication business logic, [AuthService].
///
/// This service abstracts the underlying [LocalAuthentication] plugin and
/// provides simple methods for checking and performing biometric authentication.
final authServiceProvider = Provider<AuthService>((ref) {
  final localAuth = ref.watch(localAuthProvider);
  return AuthService(localAuth);
});

/// Manages the user's preference for enabling or disabling the biometric lock feature.
///
/// This provider exposes the [AuthSettingsNotifier] to the UI, allowing widgets
/// to read and update the authentication setting.
final authSettingsProvider = NotifierProvider<AuthSettingsNotifier, bool>(() {
  return AuthSettingsNotifier();
});

/// A [Notifier] that controls the state of the biometric authentication setting.
///
/// It persists the user's choice to [SharedPreferences] and rebuilds widgets
/// when the setting is changed.
class AuthSettingsNotifier extends Notifier<bool> {
  /// The key used to store the authentication preference in SharedPreferences.
  static const _storageKey = 'is_auth_enabled';

  @override
  bool build() {
    // Watching sharedPreferencesProvider ensures the state automatically updates
    // if the preference is ever changed by another part of the app.
    final prefs = ref.watch(sharedPreferencesProvider);
    return prefs.getBool(_storageKey) ?? false;
  }

  /// Updates the biometric lock preference.
  ///
  /// Persists the new [isEnabled] value to [SharedPreferences] and updates the
  /// provider's state to trigger a UI rebuild.
  Future<void> toggleAuth(bool isEnabled) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setBool(_storageKey, isEnabled);
    state = isEnabled;
  }
}

/// Represents the possible states of the local authentication flow.
enum LocalAuthState {
  loading,      // Initial check (SPLASH/Loading)
  unauthenticated, // Auth is enabled but user hasn't proven identity
  authenticated,   // User is allowed to see the content
  disabled         // Security lock is turned off in settings
}

lib/src/core/providers/auth_state.dart:
/// Represents the possible states of the local authentication flow.
enum LocalAuthState {
  loading,      // Initial check (SPLASH/Loading)
  unauthenticated, // Auth is enabled but user hasn't proven identity
  authenticated,   // User is allowed to see the content
  disabled         // Security lock is turned off in settings
}

lib/src/core/providers/locale_provider.dart:
import 'dart:ui';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../utils/logger_service.dart';
import 'theme_provider.dart';

/// Provides and manages the application's current [Locale].
///
/// This provider determines the initial locale based on a priority system:
/// 1. User's saved preference.
/// 2. Device's system language.
/// 3. A default fallback locale.
/// It allows the UI to reactively rebuild when the locale is changed.
final localeProvider = NotifierProvider<LocaleNotifier, Locale>(() {
  return LocaleNotifier();
});

/// A [Notifier] that handles locale detection, persistence, and state management.
class LocaleNotifier extends Notifier<Locale> {
  /// The key used to persist the user's selected locale in [SharedPreferences].
  static const _storageKey = 'selected_locale';

  /// The default locale to use if no preference is set and the system locale is unsupported.
  static const _defaultLocale = Locale('en');

  /// A list of ISO 639-1 language codes that the application officially supports.
  static const _supportedLanguageCodes = ['en', 'ro', 'fr'];

  @override
  Locale build() {
    // Watches the shared preferences provider for reactive initialization.
    final prefs = ref.watch(sharedPreferencesProvider);
    final languageCode = prefs.getString(_storageKey);

    // Priority 1: Use the language code stored in user preferences.
    if (languageCode != null) {
      Logger.debug('Initializing locale from saved preference: $languageCode');
      return Locale(languageCode);
    }

    // Priority 2: If no preference is found, attempt to use the device's system language.
    final String systemLanguageCode =
        PlatformDispatcher.instance.locale.languageCode;

    if (_supportedLanguageCodes.contains(systemLanguageCode)) {
      Logger.debug('Initializing locale from system setting: $systemLanguageCode');
      return Locale(systemLanguageCode);
    }

    // Priority 3: Fallback to the default locale if the system language is not supported.
    Logger.debug(
        'System locale "$systemLanguageCode" is not supported. Falling back to default.');
    return _defaultLocale;
  }

  /// Updates the application's current locale and persists the new selection.
  ///
  /// This method saves the language code of the given [locale] to local storage
  /// and updates the provider's state, causing the UI to rebuild with the
  /// new translations.
  Future<void> setLocale(Locale locale) async {
    final prefs = ref.read(sharedPreferencesProvider);

    final success = await prefs.setString(_storageKey, locale.languageCode);

    if (success) {
      Logger.info('User changed locale to ${locale.languageCode}');
      state = locale;
    } else {
      Logger.error(
        'Failed to persist new locale setting: ${locale.languageCode}',
        'SharedPreferences.setString returned false',
        StackTrace.current,
      );
    }
  }
}

lib/src/core/providers/notification_provider.dart:
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../l10n/app_localizations.dart';
import '../utils/logger_service.dart';
import '../utils/notification_service.dart';
import 'locale_provider.dart';
import 'theme_provider.dart';

/// An immutable data class representing the user's notification settings.
@immutable
class NotificationState {
  /// Whether the daily reminder notification is enabled.
  final bool isEnabled;

  /// The hour (0-23) at which the notification should be delivered.
  final int hour;

  /// The minute (0-59) at which the notification should be delivered.
  final int minute;

  /// Creates an instance of the notification settings state.
  const NotificationState({
    this.isEnabled = false,
    this.hour = 20,
    this.minute = 0,
  });

  /// Creates a new [NotificationState] instance with updated values.
  NotificationState copyWith({bool? isEnabled, int? hour, int? minute}) {
    return NotificationState(
      isEnabled: isEnabled ?? this.isEnabled,
      hour: hour ?? this.hour,
      minute: minute ?? this.minute,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
          other is NotificationState &&
              runtimeType == other.runtimeType &&
              isEnabled == other.isEnabled &&
              hour == other.hour &&
              minute == other.minute;

  @override
  int get hashCode => isEnabled.hashCode ^ hour.hashCode ^ minute.hashCode;
}

/// Manages the state of the daily reminder notification settings.
///
/// This provider exposes the [NotificationNotifier], allowing the UI to read
/// and update notification preferences.
final notificationProvider =
NotifierProvider<NotificationNotifier, NotificationState>(() {
  return NotificationNotifier();
});

/// A [Notifier] that handles the business logic for notification settings.
///
/// This class is responsible for reading and writing settings to [SharedPreferences]
/// and interacting with the [NotificationService] to schedule or cancel
/// system alarms based on user preferences.
class NotificationNotifier extends Notifier<NotificationState> {
  /// The storage key for the notification enabled/disabled flag.
  static const String _keyEnabled = 'notifications_enabled';

  /// The storage key for the notification's scheduled hour.
  static const String _keyHour = 'notifications_hour';

  /// The storage key for the notification's scheduled minute.
  static const String _keyMinute = 'notifications_minute';

  @override
  NotificationState build() {
    final prefs = ref.watch(sharedPreferencesProvider);
    final enabled = prefs.getBool(_keyEnabled) ?? false;
    final hour = prefs.getInt(_keyHour) ?? 20;
    final minute = prefs.getInt(_keyMinute) ?? 0;
    return NotificationState(isEnabled: enabled, hour: hour, minute: minute);
  }

  /// Updates notification settings and synchronizes them with the system's scheduler.
  ///
  /// This method persists the user's choices and then either schedules a new
  /// daily reminder or cancels all existing ones. It returns a boolean
  /// indicating if the app has permission to schedule exact alarms.
  Future<bool> updateSettings(bool enabled, int h, int m,
      {bool force = false}) async {
    if (!force &&
        state.isEnabled == enabled &&
        state.hour == h &&
        state.minute == m) {
      Logger.debug('Skipping notification update; settings are unchanged.');
      return true;
    }

    try {
      Logger.info('Updating notification settings: enabled=$enabled, time=$h:$m');
      final prefs = ref.read(sharedPreferencesProvider);
      await Future.wait([
        prefs.setBool(_keyEnabled, enabled),
        prefs.setInt(_keyHour, h),
        prefs.setInt(_keyMinute, m),
      ]);

      state = state.copyWith(isEnabled: enabled, hour: h, minute: m);
      final service = ref.read(notificationServiceProvider);

      if (enabled) {
        final hasPermission = await service.requestPermission();
        if (hasPermission) {
          final currentLocale = ref.read(localeProvider);
          final l10n = await AppLocalizations.delegate.load(currentLocale);

          await service.scheduleDailyReminder(
            title: l10n.notificationTitle,
            body: l10n.notificationBody,
            hour: h,
            minute: m,
          );
          Logger.info('Scheduled daily reminder for $h:$m.');
        }
      } else {
        await service.cancelAll();
        Logger.info('Cancelled all scheduled notifications.');
      }

      return await service.canScheduleExactAlarms();
    } catch (e, stack) {
      Logger.error('Failed to update notification settings', e, stack);
      return false;
    }
  }
}

lib/src/core/providers/pdf_provider.dart:
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/utils/logger_service.dart';
import '../../features/journal/data/journal_repository.dart';
import '../utils/pdf_service.dart';

/// Provides a singleton instance of the [PdfService].
///
/// This service contains the low-level logic for creating and styling
/// PDF documents from application data.
final pdfServiceProvider = Provider<PdfService>((ref) => PdfService());

/// Provides a function that orchestrates the entire PDF export process.
///
/// This provider encapsulates the logic of fetching all journal entries from the
/// [journalRepositoryProvider] and passing them to the [pdfServiceProvider]
/// for generation and sharing. It simplifies triggering the export from the UI.
final exportPdfProvider = Provider<Future<void> Function()>((ref) {
  final repository = ref.read(journalRepositoryProvider);
  final pdfService = ref.read(pdfServiceProvider);

  return () async {
    try {
      Logger.info('PDF export process initiated by user.');
      final entries = await repository.getAllEntries();
      Logger.debug('Found ${entries.length} entries for PDF export.');

      if (entries.isNotEmpty) {
        await pdfService.generateJournalPdf(entries, "Krono Journal");
        Logger.info('Successfully generated and shared journal PDF.');
      } else {
        Logger.info('PDF export cancelled: No journal entries found.');
      }
    } catch (e, stack) {
      Logger.error('Failed to generate or share the PDF journal', e, stack);
    }
  };
});

lib/src/core/providers/streak_provider.dart:
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../database/database.dart';
import '../utils/logger_service.dart';

/// Represents the calculated state of the user's activity streak.
///
/// This is an immutable data class that holds the result of the streak calculation,
/// including the consecutive day count and the underlying activity dates.
class StreakState {
  /// The number of consecutive days of activity.
  final int count;

  /// The most recent date of any recorded activity. Can be null if no activity exists.
  final DateTime? lastActivityDate;

  /// A comprehensive, sorted list of all unique dates with recorded activity.
  final List<DateTime> activeDates;

  /// Creates an instance of the streak state.
  const StreakState({
    required this.count,
    this.lastActivityDate,
    this.activeDates = const [],
  });

  /// A factory for creating an initial, empty [StreakState].
  factory StreakState.initial() =>
      const StreakState(count: 0, activeDates: []);
}

/// Provides a continuous stream of the user's activity log from the database.
///
/// This stream automatically emits a new list of [ActivityLogData] whenever
/// the `activityLog` table is updated, ensuring reactive updates.
final activityLogStreamProvider = StreamProvider<List<ActivityLogData>>((ref) {
  final db = ref.watch(databaseProvider);
  return (db.select(db.activityLog)).watch();
});

/// Provides a continuous stream of streak adjustments from the database.
///
/// These adjustments represent manually added days, such as from a streak
/// restore feature, and are combined with the regular activity log.
final streakAdjustmentsProvider =
StreamProvider<List<StreakAdjustment>>((ref) {
  final db = ref.watch(databaseProvider);
  return (db.select(db.streakAdjustments)).watch();
});

/// The primary provider for calculating and exposing the user's activity streak.
///
/// This provider combines data from two sources: the [activityLogStreamProvider]
/// (for regular daily entries) and the [streakAdjustmentsProvider] (for manual
/// additions). It then computes the number of consecutive days of activity
/// leading up to the present day.
///
/// Importantly, deleting a journal entry does not affect the streak, as the
/// activity record persists in the dedicated `ActivityLog` table.
final streakProvider = Provider<StreakState>((ref) {
  final activityAsync = ref.watch(activityLogStreamProvider);
  final adjustmentsAsync = ref.watch(streakAdjustmentsProvider);

  // Gracefully handle loading/error states by using the last known good value or an empty list.
  final logs = activityAsync.value ?? [];
  final adjustments = adjustmentsAsync.value ?? [];

  if (logs.isEmpty && adjustments.isEmpty) {
    return StreakState.initial();
  }

  // 1. Consolidate all activity dates into a single, unique Set to prevent duplicates.
  final Set<DateTime> combinedDates = {};

  for (final log in logs) {
    combinedDates.add(DateTime(log.date.year, log.date.month, log.date.day));
  }

  for (final adj in adjustments) {
    combinedDates.add(DateTime(adj.date.year, adj.date.month, adj.date.day));
  }

  // 2. Sort the dates in descending order (most recent first).
  final sortedDates = combinedDates.toList()..sort((a, b) => b.compareTo(a));

  final now = DateTime.now();
  final today = DateTime(now.year, now.month, now.day);
  final yesterday = today.subtract(const Duration(days: 1));

  // 3. Check if the streak is active. A streak is broken if the last activity
  // was before yesterday.
  final lastActiveDate = sortedDates.first;
  if (lastActiveDate.isBefore(yesterday)) {
    Logger.debug('Streak broken: Last activity was before yesterday.');
    return StreakState(
      count: 0,
      lastActivityDate: lastActiveDate,
      activeDates: sortedDates,
    );
  }

  // 4. Calculate the number of consecutive days by iterating backwards from the last active date.
  int streakCount = 0;
  DateTime currentCheckDate = lastActiveDate;

  for (final date in sortedDates) {
    if (date.isAtSameMomentAs(currentCheckDate)) {
      streakCount++;
      currentCheckDate = currentCheckDate.subtract(const Duration(days: 1));
    } else {
      // A gap was found that is not covered by any record, so the streak ends here.
      break;
    }
  }

  return StreakState(
    count: streakCount,
    lastActivityDate: lastActiveDate,
    activeDates: sortedDates,
  );
});

lib/src/core/providers/theme_provider.dart:
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../utils/logger_service.dart';

/// Provides the global singleton instance of [SharedPreferences].
///
/// This provider is essential for persistence throughout the app. It is declared
/// here but must be initialized in the `main.dart` file by overriding its
/// value within the root [ProviderScope].
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  // This exception serves as a safeguard to ensure the provider is correctly
  // initialized at app startup.
  throw UnimplementedError(
      'sharedPreferencesProvider must be overridden in main.dart');
});

// --- THEME MODE MANAGEMENT ---

/// Manages the application's overall brightness [ThemeMode] (light, dark, or system).
///
/// This provider exposes the [ThemeNotifier], allowing the UI to reactively
/// rebuild when the theme changes and providing methods to update the theme.
final themeNotifierProvider = NotifierProvider<ThemeNotifier, ThemeMode>(() {
  return ThemeNotifier();
});

/// A [Notifier] responsible for managing and persisting the application's theme state.
///
/// On the first launch, it defaults to [ThemeMode.system], allowing the operating
/// system to control the theme. Once a user manually selects a theme, that
/// choice is persisted and will override the system setting on subsequent launches.
class ThemeNotifier extends Notifier<ThemeMode> {
  /// The key used to store the theme preference in [SharedPreferences].
  static const _themeKey = 'user_theme_preference';

  @override
  ThemeMode build() {
    final prefs = ref.watch(sharedPreferencesProvider);
    final String? savedTheme = prefs.getString(_themeKey);

    // If no preference is saved, the app will follow the system's brightness setting.
    if (savedTheme == null) {
      Logger.debug('No saved theme preference found, defaulting to system theme.');
      return ThemeMode.system;
    }

    // Maps the stored string preference back to its corresponding ThemeMode enum.
    return switch (savedTheme) {
      'dark' => ThemeMode.dark,
      'light' => ThemeMode.light,
      'system' => ThemeMode.system,
      _ => ThemeMode.system, // Fallback for any unexpected stored value.
    };
  }

  /// Toggles the theme between [ThemeMode.light] and [ThemeMode.dark].
  ///
  /// This action persists the new choice, effectively overriding the system
  /// setting until it is explicitly reset.
  Future<void> toggleTheme() async {
    final newMode =
    (state == ThemeMode.light) ? ThemeMode.dark : ThemeMode.light;
    await setTheme(newMode);
  }

  /// Sets the application theme to a specific [ThemeMode] and persists the choice.
  Future<void> setTheme(ThemeMode mode) async {
    final prefs = ref.read(sharedPreferencesProvider);
    state = mode;

    Logger.info('User changed theme to ${mode.name}.');
    await prefs.setString(_themeKey, mode.name);
  }

  /// Resets the theme preference, causing the app to follow the OS theme again.
  ///
  /// This is achieved by removing the stored preference from [SharedPreferences].
  Future<void> resetToSystem() async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.remove(_themeKey);
    state = ThemeMode.system;
    Logger.info('User reset theme to follow system setting.');
  }
}

// --- ACCENT COLOR MANAGEMENT ---

/// Manages the application's primary accent [Color].
///
/// This provider exposes the [AccentColorNotifier], allowing the UI to
/// reactively update when the accent color is changed.
final accentColorProvider = NotifierProvider<AccentColorNotifier, Color>(() {
  return AccentColorNotifier();
});

/// A [Notifier] responsible for managing and persisting the user's chosen accent color.
class AccentColorNotifier extends Notifier<Color> {
  /// The key used to store the accent color in [SharedPreferences].
  static const _accentKey = 'user_accent_color';

  /// The default brand color used if no custom color has been selected.
  static const Color kronoOriginal = Color(0xFF6366F1);

  @override
  Color build() {
    final prefs = ref.watch(sharedPreferencesProvider);
    final int? savedColorValue = prefs.getInt(_accentKey);

    return savedColorValue != null ? Color(savedColorValue) : kronoOriginal;
  }

  /// Updates the application's accent color and persists the new value.
  ///
  /// The [color] is stored as an integer representation.
  Future<void> setAccentColor(Color color) async {
    final prefs = ref.read(sharedPreferencesProvider);
    state = color;
    Logger.info('User changed accent color to ${color.toString()}.');
    // The extension method `toARGB32()` is assumed to exist on Color.
    // If not, `color.value` is the standard way to get the integer.
    await prefs.setInt(_accentKey, color.toARGB32());
  }
}

lib/src/core/utils/thumbnail/thumbnail_cleanup.dart:
import 'dart:io';

import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

import '../../database/database.dart';
import '../logger_service.dart';

/// Scans the local storage for thumbnail files that are no longer referenced in the database.
///
/// This maintenance task prevents storage bloat by identifying and removing cached
/// images that remain on the filesystem after their corresponding [DayEntry] has
/// been deleted or modified.
Future<void> cleanupOrphanThumbnails(AppDatabase db) async {
  try {
    Logger.info('Starting orphan thumbnail cleanup process.');

    // 1. Collect all thumbnail paths currently registered in the database.
    final rows = await db.select(db.dayEntries).get();
    final used = rows
        .map((r) => r.thumbnailPath)
        .where((path) => path != null && path.isNotEmpty)
        .cast<String>()
        .toSet();

    Logger.debug('Found ${used.length} thumbnails currently referenced in database.');

    // 2. Locate the thumbnails directory.
    final dir = await getApplicationSupportDirectory();
    final thumbsDir = Directory(p.join(dir.path, 'thumbnails'));

    if (!await thumbsDir.exists()) {
      Logger.info('Thumbnails directory does not exist. Skipping cleanup.');
      return;
    }

    // 3. Iterate through the filesystem and remove unreferenced files.
    int deletedCount = 0;
    await for (final entity in thumbsDir.list(recursive: false, followLinks: false)) {
      if (entity is File) {
        final filePath = entity.path;
        if (!used.contains(filePath)) {
          try {
            await entity.delete();
            deletedCount++;
            Logger.debug('Deleted orphan thumbnail: $filePath');
          } catch (e, stack) {
            // Log individual deletion failures as warnings to avoid halting the entire process.
            Logger.warning('Failed to delete specific orphan thumbnail: $filePath', e, stack);
          }
        }
      }
    }

    if (deletedCount > 0) {
      Logger.info('Cleanup completed. Removed $deletedCount orphan thumbnails.');
    } else {
      Logger.info('Cleanup completed. No orphan thumbnails were found.');
    }
  } catch (e, stack) {
    // Critical failures in the cleanup logic are reported to Crashlytics.
    Logger.error('Failed to complete orphan thumbnail cleanup', e, stack);
  }
}

lib/src/core/utils/thumbnail/thumbnail_migration.dart:
import 'dart:io';

import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:krono/src/core/utils/thumbnail/thumbnail_utils.dart';

import '../../database/database.dart';
import '../logger_service.dart';

/// Orchestrates the background generation of thumbnails for legacy journal entries.
///
/// This migration utility identifies entries missing a [DayEntry.thumbnailPath] and
/// processes them using a pool of workers to avoid blocking the main thread.
///
/// [concurrency] defines the number of parallel workers (recommended 2-4 for mobile).
/// [targetWidth] sets the resolution for the generated thumbnails.
Future<void> runBackgroundThumbnailMigration(
    AppDatabase db, {
      int concurrency = 3,
      int targetWidth = 300,
    }) async {
  try {
    final rows = await (db.select(db.dayEntries)
      ..where((t) => t.thumbnailPath.isNull() | t.thumbnailPath.equals('')))
        .get();

    if (rows.isEmpty) {
      Logger.info('All entries have thumbnails. Migration not required.');
      return;
    }

    Logger.info(
      'Starting thumbnail migration for ${rows.length} legacy images (concurrency: $concurrency).',
    );

    // Create a thread-safe queue from the retrieved rows.
    final queue = List.of(rows);
    final workers = <Future<void>>[];

    for (int w = 0; w < concurrency; w++) {
      workers.add(Future(() async {
        while (true) {
          if (queue.isEmpty) break;
          final row = queue.removeLast();

          try {
            final photoPath = row.photoPath;
            if (photoPath.isEmpty) continue;

            final file = File(photoPath);
            if (!file.existsSync()) {
              Logger.debug('Source file missing for entry ID ${row.id}: $photoPath');
              continue;
            }

            // Offload the heavy image processing to a separate isolate via compute.
            final thumbPath = await compute(
              _generateThumbCompute,
              {'path': photoPath, 'width': targetWidth},
            );

            // Persist the new thumbnail path to the database.
            await (db.update(db.dayEntries)..where((t) => t.id.equals(row.id)))
                .write(
              DayEntriesCompanion(
                thumbnailPath: Value(thumbPath),
              ),
            );

            Logger.debug('Thumbnail generated successfully for entry ID: ${row.id}');
          } catch (e, stack) {
            Logger.error('Failed to migrate thumbnail for entry ID: ${row.id}', e, stack);
          }

          // Brief delay to prevent event loop starvation during intensive processing.
          await Future.delayed(const Duration(milliseconds: 40));
        }
      }));
    }

    await Future.wait(workers);
    Logger.info('Thumbnail migration completed successfully.');
  } catch (e, stack) {
    Logger.error('Critical failure during thumbnail migration process', e, stack);
  }
}

/// Helper function executed within a [compute] isolate to generate a thumbnail.
///
/// Expects a [Map] containing the 'path' (String) and 'width' (int).
Future<String> _generateThumbCompute(Map<String, dynamic> args) async {
  final String path = args['path'] as String;
  final int width = args['width'] as int? ?? 300;
  return await generateThumbnail(path, width: width);
}

lib/src/core/utils/thumbnail/thumbnail_utils.dart:
import 'dart:io';

import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

import '../logger_service.dart';

/// Generates a high-performance WebP thumbnail for a given image file.
///
/// The thumbnail is stored in a dedicated 'thumbnails' subdirectory within the
/// application support directory. This utility includes existence checks to prevent
/// I/O exceptions. If the [originalPath] does not exist or the compression process
/// fails, the function returns the [originalPath] as a fallback to ensure the UI
/// still has a valid reference to display.
Future<String> generateThumbnail(
    String originalPath, {
      int width = 300,
      int quality = 85,
    }) async {
  try {
    final sourceFile = File(originalPath);

    // Validate file existence before attempting I/O operations to avoid PathNotFoundException.
    if (!await sourceFile.exists()) {
      Logger.debug('Thumbnail generation skipped: Source file missing at $originalPath');
      return originalPath;
    }

    final dir = await getApplicationSupportDirectory();
    final thumbsDir = Directory(p.join(dir.path, 'thumbnails'));

    // Ensure the destination directory exists.
    if (!await thumbsDir.exists()) {
      await thumbsDir.create(recursive: true);
    }

    final base = p.basenameWithoutExtension(originalPath);
    final outPath = p.join(thumbsDir.path, '${base}_thumb.webp');

    // Avoid redundant compression cycles if the thumbnail already exists on disk.
    if (await File(outPath).exists()) {
      return outPath;
    }

    // Perform native compression to WebP format for optimal size/quality ratio.
    final XFile? compressed = await FlutterImageCompress.compressAndGetFile(
      originalPath,
      outPath,
      minWidth: width,
      quality: quality,
      format: CompressFormat.webp,
    );

    return compressed?.path ?? originalPath;
  } catch (e, stack) {
    Logger.error('Failed to generate thumbnail for path: $originalPath', e, stack);
    return originalPath;
  }
}

lib/src/core/utils/activity_sync.dart:
import 'package:drift/drift.dart';

import '../database/database.dart';
import 'logger_service.dart';

/// A utility to synchronize the activity history from existing journal entries.
///
/// This function is designed to be run during app initialization. It ensures that
/// users migrating from an older app version (before the `ActivityLog` table
/// existed) have their past entries correctly reflected in the new activity log,
/// preserving their historical streak data.
Future<void> syncActivityLogFromEntries(AppDatabase db) async {
  try {
    Logger.info('Starting sync of existing entries to activity log...');

    // 1. Retrieve all existing journal entries.
    final entries = await db.select(db.dayEntries).get();

    if (entries.isEmpty) {
      Logger.info('No existing entries to sync. Activity log is up to date.');
      return;
    }

    // 2. Extract unique dates, ignoring the time component, to prevent duplicates.
    final uniqueDates = entries
        .map((e) => DateTime(e.date.year, e.date.month, e.date.day))
        .toSet();

    Logger.debug('Found ${uniqueDates.length} unique dates to sync.');

    // 3. Insert all unique dates into the ActivityLog table using a batch for performance.
    // The `insertOrIgnore` mode gracefully handles any dates that might already exist.
    await db.batch((batch) {
      for (final date in uniqueDates) {
        batch.insert(
          db.activityLog,
          ActivityLogCompanion.insert(date: date),
          mode: InsertMode.insertOrIgnore,
        );
      }
    });

    Logger.info('Successfully synced activity log from existing entries.');
  } catch (e, stack) {
    // Log the error but do not rethrow, as this is a non-critical background
    // task and should not block the application from starting.
    Logger.error('Failed to sync activity log from entries', e, stack);
  }
}

lib/src/core/utils/auth_service.dart:
import 'package:flutter/services.dart';
import 'package:local_auth/local_auth.dart';

import 'logger_service.dart';

/// A service that abstracts the `local_auth` plugin to provide a simple
/// interface for biometric and device passcode authentication.
///
/// This service centralizes authentication logic, including hardware capability
/// checks and standardized error handling.
class AuthService {
  /// The underlying `local_auth` plugin instance.
  final LocalAuthentication _auth;

  /// Creates an instance of the [AuthService].
  ///
  /// Requires an instance of [LocalAuthentication] to be injected.
  AuthService(this._auth);

  /// Verifies if the device hardware supports biometrics or a device passcode.
  ///
  /// This check is performed to determine if an authentication prompt can be shown.
  /// It returns `true` if the device can perform checks, and `false` otherwise.
  ///
  /// Implementation notes:
  /// - `canCheckBiometrics` only indicates hardware availability, not whether any biometrics are enrolled.
  /// - `getAvailableBiometrics()` returns the enrolled biometric types.
  /// - `isDeviceSupported()` returns true on devices that support local authentication methods
  ///   (including device passcode) even if no biometrics are enrolled.
  Future<bool> canAuthenticate() async {
    try {
      final bool canCheckBiometrics = await _auth.canCheckBiometrics;
      final List<BiometricType> availableBiometrics =
      await _auth.getAvailableBiometrics();
      final bool isDeviceSupported = await _auth.isDeviceSupported();

      // True if device supports authentication at OS level OR there are enrolled biometrics.
      final bool can = isDeviceSupported || availableBiometrics.isNotEmpty || canCheckBiometrics;

      Logger.debug(
        'canAuthenticate -> deviceSupported: $isDeviceSupported, '
            'canCheckBiometrics: $canCheckBiometrics, '
            'availableBiometrics: ${availableBiometrics.map((b) => b.toString()).toList()}, '
            'result: $can',
      );

      return can;
    } catch (e, stack) {
      Logger.error(
        "Hardware verification for authentication failed",
        e,
        stack,
      );
      return false;
    }
  }

  /// Returns true if there are biometrics enrolled on the device.
  Future<bool> isBiometricEnrolled() async {
    try {
      final List<BiometricType> available = await _auth.getAvailableBiometrics();
      return available.isNotEmpty;
    } catch (e, stack) {
      Logger.error("Failed to check enrolled biometrics", e, stack);
      return false;
    }
  }

  /// Initiates the native authentication prompt (e.g., Face ID, fingerprint, or passcode).
  ///
  /// Displays a system dialog to the user with the provided [reason].
  /// Returns `true` upon successful authentication, or `false` for any
  /// failures, including user cancellation or hardware errors.
  Future<bool> authenticate(String reason) async {
    try {
      if (!await canAuthenticate()) {
        Logger.warning(
            "Authentication skipped: device does not support local authentication or no biometric/passcode available.");
        return false;
      }

      Logger.info("Authentication process initiated.");

      // Use the recommended authenticate signature for local_auth 3.0.0.
      // By default this may fallback to device passcode unless biometricOnly is true.
      final bool didAuthenticate = await _auth.authenticate(
        localizedReason: reason,
        biometricOnly: false,
        sensitiveTransaction: true,
        persistAcrossBackgrounding: true,
      );

      Logger.info("Authentication completed with result: $didAuthenticate");
      return didAuthenticate;
    } on LocalAuthException catch (e, stack) {
      // The plugin uses LocalAuthException for most failure cases — log and
      // handle specific codes if needed (e.g., biometricLockout, noBiometricHardware).
      Logger.error(
        "Authentication failed due to a local auth issue: ${e.code}",
        e,
        stack,
      );

      // Example of handling specific codes (extend as needed):
      // if (e.code == LocalAuthExceptionCode.biometricLockout) { ... }

      return false;
    } on PlatformException catch (e, stack) {
      // Platform-level issues (rare but possible).
      Logger.error(
        "Authentication failed due to a platform issue: [${e.code}] ${e.message}",
        e,
        stack,
      );
      return false;
    } catch (e, stack) {
      // Fallback for any other unexpected exceptions.
      Logger.error("An unhandled error occurred during authentication", e, stack);
      return false;
    }
  }
}

lib/src/core/utils/auth_wrapper.dart:
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';

import '../../../l10n/app_localizations.dart';
import '../providers/auth_provider.dart';
import 'logger_service.dart';

/// A gatekeeper widget that enforces local authentication before revealing its [child].
///
/// This widget checks the user's preference for biometric security. If enabled,
/// it presents an authentication prompt and only builds the [child] widget tree
/// upon successful verification.
class AuthWrapper extends ConsumerStatefulWidget {
  /// The primary content to display after successful authentication.
  final Widget child;

  /// Creates an instance of the authentication gatekeeper.
  const AuthWrapper({super.key, required this.child});

  @override
  ConsumerState<AuthWrapper> createState() => _AuthWrapperState();
}

/// The state for [AuthWrapper] which manages the authentication lifecycle.
class _AuthWrapperState extends ConsumerState<AuthWrapper> {
  /// Tracks whether the user has successfully authenticated for the current session.
  bool _isSessionAuthenticated = false;

  /// Indicates if the initial security check is in progress to prevent UI flicker.
  bool _isChecking = true;

  @override
  void initState() {
    super.initState();
    _initializeSecurity();
  }

  /// Evaluates authentication requirements and triggers the biometric prompt if enabled.
  ///
  /// This is the entry point for the security check. It reads the user's preference
  /// and either grants access immediately or proceeds to the authentication flow.
  Future<void> _initializeSecurity() async {
    final isEnabled = ref.read(authSettingsProvider);

    if (!isEnabled) {
      Logger.info('Biometric lock is disabled. Granting access immediately.');
      if (mounted) {
        setState(() {
          _isChecking = false;
          _isSessionAuthenticated = true;
        });
      }
      return;
    }

    Logger.info('Biometric lock is enabled. Initiating security check.');
    // A small delay ensures the native view hierarchy is stable before presenting the dialog.
    Logger.debug('Delaying auth prompt to ensure view hierarchy is stable.');
    await Future.delayed(const Duration(milliseconds: 300));
    await _handleAuthentication();

    if (mounted) setState(() => _isChecking = false);
  }

  /// Invokes the [AuthService] to perform biometric or passcode verification.
  ///
  /// This method handles the interaction with the authentication service and updates
  /// the session state based on the outcome.
  Future<void> _handleAuthentication() async {
    final l10n = AppLocalizations.of(context)!;
    final authService = ref.read(authServiceProvider);

    final success = await authService.authenticate(l10n.authReason);

    if (success) {
      Logger.info('User successfully authenticated.');
    } else {
      Logger.info('User failed or cancelled authentication.');
    }

    if (mounted) {
      setState(() => _isSessionAuthenticated = success);
    }
  }

  @override
  Widget build(BuildContext context) {
    // Show a loading indicator during the initial check to prevent UI flickering.
    if (_isChecking && !_isSessionAuthenticated) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator.adaptive()),
      );
    }

    // Grant access if the session is authenticated or if the feature is disabled.
    // The second check on `ref.watch` ensures that if the user disables the
    // feature from settings while the app is locked, it unlocks immediately.
    if (_isSessionAuthenticated || !ref.watch(authSettingsProvider)) {
      return widget.child;
    }

    // Otherwise, show the locked screen overlay.
    return _LockedOverlay(onRetry: _handleAuthentication);
  }
}

/// A UI overlay displayed when the application is locked, prompting the user to authenticate.
class _LockedOverlay extends StatelessWidget {
  /// The callback function to execute when the user attempts to unlock the app.
  final VoidCallback onRetry;

  /// Creates the locked overlay UI.
  const _LockedOverlay({required this.onRetry});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      body: Container(
        width: double.infinity,
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              colorScheme.surface,
              colorScheme.primaryContainer.withAlpha((255 * 0.1).round()),
            ],
          ),
        ),
        padding: const EdgeInsets.symmetric(horizontal: 40),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _buildLockIcon(colorScheme),
            const Gap(32),
            Text(
              l10n.accessRestricted,
              textAlign: TextAlign.center,
              style: theme.textTheme.headlineMedium?.copyWith(
                fontWeight: FontWeight.w900,
              ),
            ),
            const Gap(12),
            Text(
              l10n.confirmIdentity,
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurface.withAlpha((255 * 0.6).round()),
              ),
            ),
            const Gap(48),
            _UnlockButton(onPressed: onRetry),
          ],
        ),
      ),
    );
  }

  /// Builds the decorative lock icon for the locked overlay.
  Widget _buildLockIcon(ColorScheme colorScheme) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: colorScheme.primary.withAlpha((255 * 0.1).round()),
        shape: BoxShape.circle,
      ),
      child: Icon(
        Icons.lock_outline_rounded,
        size: 64,
        color: colorScheme.primary,
      ),
    );
  }
}

/// A standardized button used within the [_LockedOverlay] to trigger the authentication prompt.
class _UnlockButton extends StatelessWidget {
  /// The callback function to execute when the button is pressed.
  final VoidCallback onPressed;

  /// Creates the unlock button.
  const _UnlockButton({required this.onPressed});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return SizedBox(
      width: double.infinity,
      height: 56,
      child: ElevatedButton.icon(
        onPressed: onPressed,
        icon: const Icon(Icons.fingerprint_rounded),
        label: Text(l10n.unlock),
        style: ElevatedButton.styleFrom(
          backgroundColor: colorScheme.primary,
          foregroundColor: colorScheme.onPrimary,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
        ),
      ),
    );
  }
}

lib/src/core/utils/backup_service.dart:
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:archive/archive_io.dart';
import 'package:drift/drift.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:krono/src/core/utils/thumbnail/thumbnail_utils.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

import '../../../l10n/app_localizations.dart';
import '../../features/journal/data/journal_repository.dart';
import '../database/database.dart';
import 'logger_service.dart';

/// Provides a singleton instance of the [BackupService].
final backupServiceProvider = Provider<BackupService>((ref) {
  return BackupService(ref: ref);
});

// Helper functions for isolate-based JSON processing via `compute`.
List<Map<String, dynamic>> _serializeEntries(List<DayEntry> entries) =>
    entries.map((e) => e.toJson()).toList();
List<Map<String, dynamic>> _serializeAdjustments(
    List<StreakAdjustment> adjustments) =>
    adjustments.map((e) => e.toJson()).toList();
List<Map<String, dynamic>> _serializeActivityLogs(List<ActivityLogData> logs) =>
    logs.map((e) => e.toJson()).toList();
String _jsonStringify(dynamic data) => jsonEncode(data);
List<dynamic> _jsonParse(String data) => jsonDecode(data) as List<dynamic>;

/// A service that handles the creation and restoration of full application backups.
///
/// This service orchestrates the process of collecting all user data (database
/// records and media files), packaging it into a single `.zip` archive for export,
/// and importing data from such an archive to restore the application state.
class BackupService {
  /// A Riverpod [Ref] to access other providers like the database.
  final Ref _ref;

  /// Creates an instance of the [BackupService].
  BackupService({required Ref ref}) : _ref = ref;

  /// Exports all user data into a single compressed `.zip` file.
  ///
  /// This method gathers all database tables and associated media files,
  /// generates thumbnails if missing, and prompts the user to save the
  /// resulting archive. Returns `true` if the user successfully saves the file.
  Future<bool> exportFullBackup(AppLocalizations l10n) async {
    Logger.info('Full backup export process initiated.');
    File? tempZipFile;
    try {
      final timestamp =
      DateTime.now().toIso8601String().replaceAll(':', '-').substring(0, 19);
      final fileName = 'krono_backup_$timestamp.zip';
      final tempDir = await getTemporaryDirectory();
      final tempZipPath = p.join(tempDir.path, fileName);

      final encoder = ZipFileEncoder();
      encoder.create(tempZipPath);

      final db = _ref.read(databaseProvider);

      // Serialize and add database tables to the archive.
      final allEntries = await db.select(db.dayEntries).get();
      final dbJson = await compute(_serializeEntries, allEntries);
      final dbContent = await compute(_jsonStringify, dbJson);
      encoder.addArchiveFile(ArchiveFile(
          'database.json', dbContent.length, utf8.encode(dbContent)));

      final allAdjustments = await db.select(db.streakAdjustments).get();
      final adjJson = await compute(_serializeAdjustments, allAdjustments);
      final adjContent = await compute(_jsonStringify, adjJson);
      encoder.addArchiveFile(ArchiveFile(
          'adjustments.json', adjContent.length, utf8.encode(adjContent)));

      final allLogs = await db.select(db.activityLog).get();
      final logsJson = await compute(_serializeActivityLogs, allLogs);
      final logsContent = await compute(_jsonStringify, logsJson);
      encoder.addArchiveFile(ArchiveFile(
          'activity_log.json', logsContent.length, utf8.encode(logsContent)));

      Logger.debug('Processed ${allEntries.length} entries for backup.');

      // Add all associated media files to the archive.
      int count = 0;
      for (final entry in allEntries) {
        final photoName = p.basename(entry.photoPath);
        final photoFile = File(entry.photoPath);

        if (entry.photoPath.isNotEmpty && await photoFile.exists()) {
          encoder.addFile(photoFile, 'media/$photoName');

          File? thumbFile;
          String? thumbName;
          if (entry.thumbnailPath != null && entry.thumbnailPath!.isNotEmpty) {
            final tFile = File(entry.thumbnailPath!);
            if (await tFile.exists()) {
              thumbFile = tFile;
              thumbName = p.basename(entry.thumbnailPath!);
            }
          }
          // If thumbnail is missing, generate it on-the-fly for the backup.
          if (thumbFile == null) {
            try {
              final newThumbPath =
              await generateThumbnail(entry.photoPath, width: 300);
              final newThumbFile = File(newThumbPath);
              if (await newThumbFile.exists()) {
                thumbFile = newThumbFile;
                thumbName = p.basename(newThumbPath);
                await (db.update(db.dayEntries)
                  ..where((t) => t.id.equals(entry.id)))
                    .write(
                    DayEntriesCompanion(thumbnailPath: Value(newThumbPath)));
              }
            } catch (e, stack) {
              Logger.warning(
                  'Could not generate missing thumbnail during backup',
                  e,
                  stack);
            }
          }
          if (thumbFile != null && thumbName != null) {
            encoder.addFile(thumbFile, 'media/$thumbName');
          }
        }
        count++;
        // Yield to the event loop to prevent UI jank during large exports.
        if (count % 10 == 0) await Future.delayed(const Duration(milliseconds: 1));
      }

      encoder.close();
      tempZipFile = File(tempZipPath);
      final Uint8List zipBytes = await tempZipFile.readAsBytes();

      // Prompt user to save the file.
      final String? result = await FilePicker.platform.saveFile(
        dialogTitle: l10n.exportBackup,
        fileName: fileName,
        type: FileType.custom,
        allowedExtensions: ['zip'],
        bytes: zipBytes,
      );

      if (result != null) {
        Logger.info('Full backup successfully saved by user.');
        return true;
      } else {
        Logger.info('User cancelled the backup export.');
        return false;
      }
    } catch (e, st) {
      Logger.error("Full backup export failed", e, st);
      return false;
    } finally {
      if (tempZipFile != null && await tempZipFile.exists()) {
        await tempZipFile.delete();
      }
      await cleanupCache();
    }
  }

  /// Imports user data from a `.zip` backup file, overwriting existing data.
  ///
  /// This method prompts the user to select a backup file, clears all current
  /// data, and then restores the state from the archive. It is backwards-
  /// compatible and can handle both modern and legacy backup formats.
  Future<bool> importFullBackup() async {
    Logger.info('Full backup import process initiated.');
    try {
      final result = await FilePicker.platform
          .pickFiles(type: FileType.custom, allowedExtensions: ['zip']);
      if (result == null || result.files.single.path == null) {
        Logger.info('User cancelled the backup import file selection.');
        return false;
      }

      final zipPath = result.files.single.path!;
      Logger.debug('Selected backup file for import: $zipPath');
      final archive =
      ZipDecoder().decodeBytes(await File(zipPath).readAsBytes());

      // Clear all existing data before importing.
      Logger.info('Clearing existing user data before import.');
      final db = _ref.read(databaseProvider);
      await _ref.read(journalRepositoryProvider).deleteAllData();
      await db.delete(db.streakAdjustments).go();
      await db.delete(db.activityLog).go();

      final appDir = await getApplicationDocumentsDirectory();
      final mediaDir = Directory(p.join(appDir.path, 'media'));
      if (!await mediaDir.exists()) await mediaDir.create(recursive: true);

      final Map<String, String> oldToNewPathMap = {};

      // 1. Extract all media files, supporting both 'media/' and legacy 'images/' paths.
      for (final file in archive.files) {
        if (file.isFile) {
          if (file.name.contains('media/') || file.name.contains('images/')) {
            final normalizedName = file.name.replaceAll('\\', '/');
            final filename = normalizedName.split('/').last;

            final destPath = p.join(mediaDir.path, filename);
            await File(destPath).writeAsBytes(file.content as List<int>);

            oldToNewPathMap[filename] = destPath;
          }
        }
      }
      Logger.debug(
          'Extracted ${oldToNewPathMap.length} media files from archive.');

      // 2. Restore database records.

      // Case A: Modern backup format (database.json).
      final dbFile = archive.findFile('database.json');
      if (dbFile != null) {
        Logger.info(
            "Found modern backup format (database.json). Proceeding with import.");
        final List<dynamic> dbJson = await compute(
            _jsonParse, utf8.decode(dbFile.content as List<int>));
        await db.batch((batch) {
          for (final entry in dbJson) {
            final rawPhotoPath =
                entry['photoPath']?.toString() ?? entry['photo_path']?.toString() ?? '';
            final photoName = p.basename(rawPhotoPath);
            final newPhotoPath = oldToNewPathMap[photoName] ?? '';

            if (newPhotoPath.isEmpty && photoName.isNotEmpty) continue;

            final rawThumbPath = entry['thumbnailPath']?.toString() ??
                entry['thumbnail_path']?.toString();
            String? newThumbPath;
            if (rawThumbPath != null) {
              final thumbName = p.basename(rawThumbPath);
              newThumbPath = oldToNewPathMap[thumbName];
            }

            DateTime entryDate;
            final rawDate = entry['date'];
            if (rawDate is int) {
              entryDate = DateTime.fromMillisecondsSinceEpoch(rawDate);
            } else {
              entryDate = DateTime.parse(rawDate.toString());
            }

            batch.insert(
                db.dayEntries,
                DayEntriesCompanion.insert(
                  date: entryDate,
                  photoPath: newPhotoPath,
                  thumbnailPath: Value(newThumbPath),
                  moodRating: entry['moodRating'] ?? entry['mood_rating'] ?? 3,
                  note: Value(entry['note']),
                  location: Value(entry['location']),
                  weatherTemp:
                  Value(entry['weatherTemp'] ?? entry['weather_temp']),
                  weatherIcon:
                  Value(entry['weatherIcon'] ?? entry['weather_icon']),
                ));
          }
        });

        // Restore auxiliary tables if they exist in the backup.
        await _restoreAuxTables(archive, db);
      }
      // Case B: Legacy backup format (data.json).
      else {
        final legacyFile = archive.findFile('data.json');
        if (legacyFile != null) {
          Logger.info(
              "Found legacy backup format (data.json). Proceeding with import.");
          final List<dynamic> legacyJson = await compute(
              _jsonParse, utf8.decode(legacyFile.content as List<int>));

          await db.batch((batch) {
            for (final item in legacyJson) {
              final photoName = p.basename(item['photoPath'] ?? '');
              final newPhotoPath = oldToNewPathMap[photoName] ?? '';

              if (newPhotoPath.isEmpty) continue;

              final date = DateTime.parse(item['date']);

              batch.insert(
                  db.dayEntries,
                  DayEntriesCompanion.insert(
                    date: date,
                    photoPath: newPhotoPath,
                    moodRating: item['moodRating'] ?? 3,
                    note: Value(item['note']),
                    location: Value(item['location']),
                    weatherTemp: Value(item['weatherTemp']),
                    weatherIcon: Value(item['weatherIcon']),
                    thumbnailPath: const Value(null),
                  ));

              // Critically, generate ActivityLog entries from legacy data to ensure
              // the streak is correctly calculated after import.
              final normalizedDate = DateTime(date.year, date.month, date.day);
              batch.insert(
                  db.activityLog, ActivityLogCompanion.insert(date: normalizedDate),
                  mode: InsertMode.insertOrIgnore);
            }
          });
        } else {
          final err = Exception(
              "No valid database file found (checked database.json and data.json)");
          Logger.error(
              'Archive is missing a valid database file.', err, StackTrace.current);
          return false;
        }
      }

      Logger.info('Full backup import completed successfully.');
      return true;
    } catch (e, st) {
      Logger.error("Full backup import failed", e, st);
      return false;
    } finally {
      await cleanupCache();
    }
  }

  /// A helper method to restore data for auxiliary tables from a backup archive.
  Future<void> _restoreAuxTables(Archive archive, AppDatabase db) async {
    // Restore Streak Adjustments
    final adjFile = archive.findFile('adjustments.json');
    if (adjFile != null) {
      Logger.debug('Restoring streak adjustments...');
      final List<dynamic> adjJson = await compute(
          _jsonParse, utf8.decode(adjFile.content as List<int>));
      await db.batch((batch) {
        for (final adj in adjJson) {
          final rawDate = adj['date'];
          final date = rawDate is int
              ? DateTime.fromMillisecondsSinceEpoch(rawDate)
              : DateTime.parse(rawDate.toString());
          batch.insert(
              db.streakAdjustments,
              StreakAdjustmentsCompanion.insert(
                date: date,
                type: adj['type'] ?? 'restore',
              ));
        }
      });
    }

    // Restore Activity Logs
    final logFile = archive.findFile('activity_log.json');
    if (logFile != null) {
      Logger.debug('Restoring activity logs...');
      final List<dynamic> logJson = await compute(
          _jsonParse, utf8.decode(logFile.content as List<int>));
      await db.batch((batch) {
        for (final log in logJson) {
          final rawDate = log['date'];
          final date = rawDate is int
              ? DateTime.fromMillisecondsSinceEpoch(rawDate)
              : DateTime.parse(rawDate.toString());
          batch.insert(db.activityLog, ActivityLogCompanion.insert(date: date),
              mode: InsertMode.insertOrIgnore);
        }
      });
    }
  }

  /// Cleans up any temporary files created by the file picker plugin.
  static Future<void> cleanupCache() async {
    try {
      Logger.debug('Clearing temporary file picker cache.');
      await FilePicker.platform.clearTemporaryFiles();
    } catch (e, stack) {
      Logger.warning(
          'Failed to clear temporary file cache. This is a non-critical error.',
          e,
          stack);
    }
  }
}

lib/src/core/utils/image_service.dart:
import 'dart:io';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';


import 'logger_service.dart';

/// A service dedicated to optimizing images and managing permanent filesystem storage.
class ImageService {
  /// Optimizes a raw image from [sourcePath], converts it to WebP, and persists it.
  ///
  /// @param deleteSource If true, the original file at [sourcePath] will be deleted.
  /// This should only be used for temporary files (e.g., from the camera).
  /// Returns the absolute path of the new image or null on failure.
  Future<String?> processAndOptimizeImage(String sourcePath, {bool deleteSource = false}) async {
    try {
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) {
        Logger.debug('Image source file does not exist at: $sourcePath');
        return null;
      }

      final dir = await getApplicationDocumentsDirectory();
      final fileName = 'krono_${DateTime.now().millisecondsSinceEpoch}.webp';
      final permanentPath = p.join(dir.path, fileName);

      Logger.info('Initiating native WebP compression for image.');

      final XFile? result = await FlutterImageCompress.compressAndGetFile(
        sourcePath,
        permanentPath,
        quality: 85,
        format: CompressFormat.webp,
      );

      if (result == null) {
        Logger.debug('Native compression returned a null result.');
        return null;
      }

      final permanentFile = File(result.path);
      if (await permanentFile.exists()) {
        Logger.info('Successfully persisted optimized image.');

        // ✅ SAFETY FIX: Only delete the source file if explicitly instructed.
        if (deleteSource) {
          await _deleteSilently(sourcePath);
        }
        return result.path;
      }

      return null;
    } catch (e, stack) {
      Logger.error('Failed to process and optimize image', e, stack);
      return null;
    }
  }

  /// Removes a file from the local filesystem at the specified [path].
  Future<void> deleteFile(String? path) async {
    if (path == null || path.isEmpty) return;
    await _deleteSilently(path);
  }

  /// Attempts to delete a file at [path] without propagating exceptions.
  Future<void> _deleteSilently(String path) async {
    try {
      final file = File(path);
      if (await file.exists()) {
        await file.delete();
        Logger.debug('Successfully deleted file: $path');
      }
    } catch (e, stack) {
      Logger.error('Failed to perform silent file deletion for path: $path', e, stack);
    }
  }
}

lib/src/core/utils/logger_service.dart:
import 'dart:developer' as dev;

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/foundation.dart';

/// A centralized logging utility for the application.
///
/// Provides a standardized interface for different log levels, integrating
/// with `dart:developer` for local debugging and `FirebaseCrashlytics`
/// for production error reporting.
///
/// Safe to use before Firebase is initialized (logs will be skipped or printed locally).
class Logger {
  /// Private constructor to prevent instantiation of this utility class.
  Logger._();

  /// Checks if Firebase has been initialized to prevent [FirebaseCrashlytics] errors.
  static bool get _isFirebaseReady => Firebase.apps.isNotEmpty;

  /// Logs a verbose message, intended for deep debugging.
  ///
  /// Use for tracking variable states, raw data dumps, or function entry/exit points.
  /// These logs are only visible in the debug console and are completely stripped
  /// from release builds due to the [kDebugMode] check.
  static void debug(String message) {
    if (kDebugMode) {
      // Using dart:developer's log to prevent truncation of long messages in the console.
      dev.log('🐛 [DEBUG]: $message', name: 'Krono');
    }
  }

  /// Logs an informational message that tracks application flow.
  ///
  /// Use for significant user actions, navigation events, or state changes.
  /// In `kDebugMode`, it prints to the console. In all builds, it is sent
  /// to Crashlytics as a breadcrumb to provide context for potential errors.
  static void info(String message) {
    if (kDebugMode) {
      debugPrint('ℹ️ [INFO]: $message');
    }

    if (_isFirebaseReady) {
      try {
        FirebaseCrashlytics.instance.log(message);
      } catch (_) {
        // Silently fail if Crashlytics has issues
      }
    }
  }

  /// Logs a non-fatal warning.
  ///
  /// Use for handled exceptions or recoverable errors where the application can
  /// continue, such as a failed network request that will be retried.
  /// The optional [error] and [stackTrace] are recorded in Crashlytics as a non-fatal issue.
  static void warning(String message, [dynamic error, StackTrace? stackTrace]) {
    if (kDebugMode) {
      debugPrint('⚠️ [WARNING]: $message');
    }

    if (_isFirebaseReady) {
      try {
        FirebaseCrashlytics.instance.log('WARNING: $message');
        if (error != null) {
          FirebaseCrashlytics.instance
              .recordError(error, stackTrace, printDetails: false);
        }
      } catch (_) {}
    }
  }

  /// Logs a critical, potentially fatal error.
  ///
  /// This should be used exclusively in `catch` blocks for unexpected exceptions
  /// that disrupt the user experience. The [message], [error], and [stackTrace]
  /// are sent to Crashlytics as a fatal issue, which will trigger alerts.
  static void error(String message, dynamic error, StackTrace stackTrace) {
    // Always print to console in Debug mode
    if (kDebugMode) {
      dev.log(
        '🚨 [ERROR]: $message',
        error: error,
        stackTrace: stackTrace,
        name: 'Krono',
      );
    } else {
      // In release mode, if Firebase isn't ready, print to stdout so we can debug startup crashes
      if (!_isFirebaseReady) {
        debugPrint('🚨 [ERROR - NO FIREBASE]: $message\n$error\n$stackTrace');
      }
    }

    if (_isFirebaseReady) {
      try {
        // Add a final log message for context before reporting the error.
        FirebaseCrashlytics.instance.log('CRITICAL: $message');
        FirebaseCrashlytics.instance.recordError(error, stackTrace, fatal: true);
      } catch (_) {}
    }
  }
}

lib/src/core/utils/notification_service.dart:
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_timezone/flutter_timezone.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:timezone/data/latest_all.dart' as tz;
import 'package:timezone/timezone.dart' as tz;

import 'logger_service.dart';

/// Provides a singleton instance of [NotificationService].
final notificationServiceProvider = Provider<NotificationService>((ref) {
  return NotificationService(FlutterLocalNotificationsPlugin());
});

/// Service responsible for managing local notifications, permissions, and scheduling.
///
/// This service handles the complexities of timezone detection, platform-specific
/// permission requests (Android/iOS), and ensures daily reminders are scheduled
/// according to the user's local time.
class NotificationService {
  final FlutterLocalNotificationsPlugin _notificationsPlugin;

  /// Creates a [NotificationService] with the required [FlutterLocalNotificationsPlugin].
  NotificationService(this._notificationsPlugin);

  /// Initializes the notification engine and configures the local timezone location.
  ///
  /// This method performs complex timezone detection with multiple fallback layers
  /// to ensure the scheduling engine functions even if system reporting is irregular.
  Future<void> init() async {
    tz.initializeTimeZones();

    try {
      final dynamic rawLocation = await FlutterTimezone.getLocalTimezone();
      String timeZoneName = rawLocation?.toString() ?? 'UTC';

      // Handle "TimezoneInfo(Europe/Bucharest)" format found on some devices.
      if (timeZoneName.contains('(')) {
        timeZoneName = timeZoneName.split('(').last.replaceAll(')', '');
      }

      // Handle "locale: ..., name: ..." format; if localized, fallback to system ID.
      if (timeZoneName.contains('name: ')) {
        timeZoneName = DateTime.now().timeZoneName;
      }

      try {
        tz.setLocalLocation(tz.getLocation(timeZoneName));
        Logger.info('Local timezone set to: $timeZoneName');
      } catch (_) {
        // Fallback: If the detected ID is invalid, try the system's short name.
        try {
          final systemName = DateTime.now().timeZoneName;
          tz.setLocalLocation(tz.getLocation(systemName));
          Logger.info('Timezone detection fallback to system name: $systemName');
        } catch (e2, stack) {
          tz.setLocalLocation(tz.UTC);
          Logger.warning('All timezone detection failed. Defaulting to UTC.', e2, stack);
        }
      }
    } catch (e, stack) {
      Logger.error('Fatal initialization error in NotificationService', e, stack);
      tz.setLocalLocation(tz.UTC);
    }

    const AndroidInitializationSettings androidSettings =
    AndroidInitializationSettings('notification_icon');

    const DarwinInitializationSettings iosSettings = DarwinInitializationSettings(
      requestAlertPermission: false,
      requestBadgePermission: false,
      requestSoundPermission: false,
    );

    await _notificationsPlugin.initialize(
      const InitializationSettings(android: androidSettings, iOS: iosSettings),
    );
  }

  /// Verifies if the application has permission to schedule exact alarms.
  ///
  /// On Android 12+, exact alarms require specific user permission.
  /// Returns `true` if permitted or if the platform does not require it.
  Future<bool> canScheduleExactAlarms() async {
    if (Platform.isAndroid) {
      return await Permission.scheduleExactAlarm.isGranted;
    }
    return true;
  }

  /// Redirects the user to the system settings to permit exact alarms.
  Future<void> openExactAlarmSettings() async {
    if (Platform.isAndroid) {
      Logger.info('Requesting exact alarm permission from user.');
      await Permission.scheduleExactAlarm.request();
    }
  }

  /// Requests the necessary notification permissions from the operating system.
  ///
  /// Handles both Android and iOS platform-specific permission implementations.
  /// Returns `true` if the user grants the required permissions.
  Future<bool> requestPermission() async {
    if (Platform.isAndroid) {
      final androidImpl = _notificationsPlugin
          .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
      return await androidImpl?.requestNotificationsPermission() ?? false;
    } else if (Platform.isIOS) {
      final iosImpl = _notificationsPlugin
          .resolvePlatformSpecificImplementation<IOSFlutterLocalNotificationsPlugin>();
      return await iosImpl?.requestPermissions(alert: true, badge: true, sound: true) ?? false;
    }
    return true;
  }

  /// Schedules a recurring daily notification at the specified [hour] and [minute].
  ///
  /// This method cancels all existing notifications before scheduling the new one
  /// to ensure no duplicate reminders are active. It uses [title] and [body]
  /// for the notification content.
  Future<void> scheduleDailyReminder({
    required String title,
    required String body,
    required int hour,
    required int minute,
  }) async {
    await _notificationsPlugin.cancelAll();

    final scheduledDate = _nextInstanceOfTime(hour, minute);
    final bool hasExactPermission = await canScheduleExactAlarms();

    try {
      await _notificationsPlugin.zonedSchedule(
        0,
        title,
        body,
        scheduledDate,
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'daily_reminder_channel_v5',
            'Jurnal Zilnic',
            importance: Importance.max,
            priority: Priority.high,
            color: Color(0xFF6366F1),
          ),
          iOS: DarwinNotificationDetails(),
        ),
        androidScheduleMode: hasExactPermission
            ? AndroidScheduleMode.exactAllowWhileIdle
            : AndroidScheduleMode.inexactAllowWhileIdle,
        matchDateTimeComponents: DateTimeComponents.time,
      );
      Logger.info('Daily reminder scheduled for $hour:$minute (Exact: $hasExactPermission)');
    } catch (e, stack) {
      Logger.error('Failed to schedule daily reminder', e, stack);
    }
  }

  /// Cancels all active and pending notifications managed by this service.
  Future<void> cancelAll() async {
    Logger.info('Cancelling all active notifications.');
    await _notificationsPlugin.cancelAll();
  }

  /// Calculates the next [tz.TZDateTime] for a given [hour] and [minute].
  ///
  /// If the specified time has already passed today, it returns the time for tomorrow.
  tz.TZDateTime _nextInstanceOfTime(int hour, int minute) {
    final tz.TZDateTime now = tz.TZDateTime.now(tz.local);
    tz.TZDateTime scheduledDate = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      hour,
      minute,
    );

    if (scheduledDate.isBefore(now)) {
      scheduledDate = scheduledDate.add(const Duration(days: 1));
    }
    return scheduledDate;
  }
}

lib/src/core/utils/pdf_service.dart:
import 'dart:io';

import 'package:intl/intl.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';

import '../../core/utils/logger_service.dart';
import '../../features/journal/data/models/journal_entry.dart';

/// A service responsible for generating, formatting, and exporting PDF documents.
///
/// This service is decoupled from the database layer and operates on
/// [JournalEntry] domain models to produce a visual representation of the journal.
class PdfService {
  /// Maps a numerical mood rating (1-5) to a corresponding emoji string.
  String _getMoodEmoji(int rating) {
    switch (rating) {
      case 1:
        return '😢';
      case 2:
        return '😐';
      case 3:
        return '😊';
      case 4:
        return '😁';
      case 5:
        return '🤩';
      default:
        return '😶';
    }
  }

  /// Generates a visual journal PDF and invokes the native sharing dialog.
  ///
  /// The document includes a cover page followed by a chronological list of
  /// [entries] formatted with the provided [title]. It utilizes Google Fonts
  /// to ensure proper Unicode and Emoji rendering.
  Future<void> generateJournalPdf(
      List<JournalEntry> entries, String title) async {
    Logger.info('PDF generation process started for ${entries.length} entries.');

    try {
      final pdf = pw.Document();

      // Loading fonts for proper Unicode and Emoji support
      final font = await PdfGoogleFonts.robotoRegular();
      final boldFont = await PdfGoogleFonts.robotoBold();
      final emojiFont = await PdfGoogleFonts.notoColorEmoji();

      // 1. Cover Page
      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (context) => pw.Center(
            child: pw.Column(
              mainAxisAlignment: pw.MainAxisAlignment.center,
              children: [
                pw.Text(
                  title,
                  style: pw.TextStyle(
                    fontSize: 40,
                    fontWeight: pw.FontWeight.bold,
                    color: PdfColors.indigo,
                  ),
                ),
                pw.SizedBox(height: 20),
                pw.Divider(
                    indent: 100, endIndent: 100, color: PdfColors.indigo200),
                pw.SizedBox(height: 10),
                pw.Text("Jurnal Personal",
                    style:
                    const pw.TextStyle(fontSize: 18, color: PdfColors.grey700)),
                pw.SizedBox(height: 50),
                pw.Text(
                    "Exportat la: ${DateFormat('dd/MM/yyyy').format(DateTime.now())}"),
              ],
            ),
          ),
        ),
      );

      // 2. Content Pages
      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(40),
          maxPages: 1000,
          theme: pw.ThemeData.withFont(
            base: font,
            bold: boldFont,
            fontFallback: [emojiFont],
          ),
          build: (context) {
            List<pw.Widget> widgets = [];

            for (var entry in entries) {
              widgets.add(
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    pw.Text(
                      DateFormat('EEEE, d MMM yyyy')
                          .format(entry.date)
                          .toUpperCase(),
                      style: pw.TextStyle(
                        fontWeight: pw.FontWeight.bold,
                        fontSize: 10,
                        color: PdfColors.indigo700,
                      ),
                    ),
                    pw.Text(_getMoodEmoji(entry.moodRating),
                        style: const pw.TextStyle(fontSize: 14)),
                  ],
                ),
              );

              widgets.add(pw.SizedBox(height: 10));

              if (entry.photoPath.isNotEmpty) {
                final img = _buildSafeImage(entry.photoPath);
                if (img != null) widgets.add(img);
              }

              if (entry.note != null && entry.note!.isNotEmpty) {
                widgets.add(
                  pw.Paragraph(
                    text: entry.note!,
                    style: const pw.TextStyle(
                        fontSize: 11, lineSpacing: 2, color: PdfColors.grey900),
                    margin: const pw.EdgeInsets.only(top: 5),
                  ),
                );
              }

              widgets.add(pw.Padding(
                padding: const pw.EdgeInsets.symmetric(vertical: 15),
                child: pw.Divider(thickness: 0.5, color: PdfColors.grey300),
              ));
            }

            return widgets;
          },
          footer: (context) => pw.Container(
            alignment: pw.Alignment.centerRight,
            child: pw.Text('Pagina ${context.pageNumber}',
                style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey)),
          ),
        ),
      );

      final bytes = await pdf.save();
      Logger.info('PDF generated successfully. Initiating share dialog.');

      await Printing.sharePdf(
        bytes: bytes,
        filename: '${title.replaceAll(' ', '_')}.pdf',
      );
    } catch (e, stack) {
      Logger.error('Critical failure during PDF generation or sharing', e, stack);
    }
  }

  /// Attempts to load an image file from the provided [path] and format it for the PDF.
  ///
  /// Returns a [pw.Widget] containing the clipped image if the file exists and
  /// is valid; otherwise, returns null and logs the failure.
  pw.Widget? _buildSafeImage(String path) {
    final file = File(path);
    if (!file.existsSync()) {
      Logger.debug('Skipping PDF image: File does not exist at $path');
      return null;
    }

    try {
      final image = pw.MemoryImage(file.readAsBytesSync());
      return pw.Center(
        child: pw.Container(
          constraints: const pw.BoxConstraints(maxHeight: 220),
          margin: const pw.EdgeInsets.symmetric(vertical: 10),
          child: pw.ClipRRect(
            horizontalRadius: 8,
            verticalRadius: 8,
            child: pw.Image(image),
          ),
        ),
      );
    } catch (e, stack) {
      Logger.error('Failed to process image for PDF inclusion: $path', e, stack);
      return null;
    }
  }
}

lib/src/core/utils/theme.dart:
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

/// Provides centralized theme configurations for the application.
///
/// This class encapsulates the logic for generating Material 3 [ThemeData]
/// based on user preferences such as accent colors and brightness modes. It
/// ensures a consistent visual identity across the entire widget tree.
class AppTheme {
  /// The standard corner radius applied to cards and surface containers.
  static const double _cardRadius = 24.0;

  /// Generates the light [ThemeData] derived from the provided [accentColor].
  ///
  /// Uses the [accentColor] as a seed to generate a harmonious Material 3
  /// [ColorScheme]. This method configures global component themes for the
  /// [AppBar] and [Card] to maintain a clean, flat aesthetic by disabling
  /// unnecessary elevations and tinting.
  static ThemeData createLightTheme(Color accentColor) {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorSchemeSeed: accentColor,

      // Applies the Poppins font family across the entire application.
      textTheme: GoogleFonts.poppinsTextTheme(),

      appBarTheme: const AppBarTheme(
        centerTitle: false,
        // Disabling scrolledUnderElevation prevents the AppBar from changing
        // color when content scrolls beneath it.
        scrolledUnderElevation: 0,
        surfaceTintColor: Colors.transparent,
        backgroundColor: Colors.transparent,
      ),

      cardTheme: CardThemeData(
        elevation: 2,
        // Ensures the card surface remains white rather than adopting
        // a primary-colored tint from the Material 3 color scheme.
        surfaceTintColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(_cardRadius),
        ),
      ),
    );
  }

  /// Generates the dark [ThemeData] derived from the provided [accentColor].
  ///
  /// This configuration is optimized for OLED displays using a near-black
  /// background to improve contrast and energy efficiency. It mirrors the
  /// component configurations of the light theme while adjusting surface
  /// colors for high legibility in low-light environments.
  static ThemeData createDarkTheme(Color accentColor) {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorSchemeSeed: accentColor,

      // OLED-optimized background for deeper blacks.
      scaffoldBackgroundColor: const Color(0xFF0D0D0D),

      textTheme: GoogleFonts.poppinsTextTheme(ThemeData.dark().textTheme),

      appBarTheme: const AppBarTheme(
        centerTitle: false,
        scrolledUnderElevation: 0,
        surfaceTintColor: Colors.transparent,
        backgroundColor: Colors.transparent,
      ),

      cardTheme: CardThemeData(
        elevation: 0,
        // Uses a slightly lighter grey for cards to provide visual depth
        // against the true black scaffold background.
        color: const Color(0xFF1A1A1A),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(_cardRadius),
        ),
      ),
    );
  }
}

lib/src/core/utils/weather_service.dart:
import 'dart:convert';
import 'dart:io';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http/http.dart' as http;

import '../utils/logger_service.dart';

/// Provides a singleton instance of the [WeatherService].
final weatherServiceProvider =
Provider<WeatherService>((ref) => WeatherService());

/// A simple data model representing the displayable weather conditions.
class WeatherData {
  /// The formatted temperature string (e.g., "25°C, Sunny").
  final String temperature;

  /// The icon code provided by the API, used to resolve the weather image asset.
  final String iconCode;

  const WeatherData({required this.temperature, required this.iconCode});
}

/// Service responsible for fetching real-time weather data.
///
/// Integrates with the OpenWeatherMap API to retrieve current conditions
/// based on geographic coordinates. Requires an API key to be injected
/// via the `--dart-define=OPEN_WEATHER_API_KEY=...` build flag.
class WeatherService {
  static const String _baseUrl =
      'https://api.openweathermap.org/data/2.5/weather';

  /// The API key retrieved from the build environment.
  static const String _apiKey = String.fromEnvironment('OPEN_WEATHER_API_KEY');

  /// Fetches the current weather conditions for the specified coordinates.
  ///
  /// This method constructs the API request using the [lat], [lon], and [langCode].
  /// It handles HTTP errors and network connectivity issues, logging failures
  /// to Crashlytics for analysis.
  ///
  /// Throws an [HttpException] if the API key is missing or the server returns an error.
  /// Throws a [SocketException] if there is no internet connection.
  Future<WeatherData> fetchWeather({
    required double lat,
    required double lon,
    required String langCode,
    http.Client? client, // Dependency Injection for testing
  }) async {
    // Validate configuration before attempting the request.
    if (_apiKey.isEmpty) {
      const error = HttpException('Missing API Key');
      Logger.error(
        'WeatherService configuration error: OPEN_WEATHER_API_KEY is not defined.',
        error,
        StackTrace.current,
      );
      throw error;
    }

    try {
      final uri = Uri.parse(
        '$_baseUrl?lat=$lat&lon=$lon&appid=$_apiKey&units=metric&lang=$langCode',
      );

      Logger.debug('Fetching weather data for coordinates: $lat, $lon');

      // Use the injected client or fallback to the default http client.
      final response = await (client ?? http.Client()).get(uri);

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final temp = (data['main']['temp'] as num).round();
        final description = data['weather'][0]['description'] as String;
        final icon = data['weather'][0]['icon'] as String;

        // Capitalize the first letter of the description for display consistency.
        final formattedDesc = description.isNotEmpty
            ? "${description[0].toUpperCase()}${description.substring(1)}"
            : description;

        Logger.info('Weather successfully fetched: $temp°C, $formattedDesc');

        return WeatherData(
          temperature: "$temp°C, $formattedDesc",
          iconCode: icon,
        );
      } else {
        final errorMsg = 'Weather API Error: ${response.statusCode} - ${response.body}';
        Logger.error(
          'Weather API returned a non-200 status code.',
          HttpException(errorMsg),
          StackTrace.current,
        );
        throw HttpException('Weather API Error: ${response.statusCode}');
      }
    } on SocketException catch (e, stack) {
      // Log as a warning since network issues are expected and recoverable.
      Logger.warning('Failed to fetch weather due to network issues.', e, stack);
      throw const SocketException('No internet connection');
    } catch (e, stack) {
      Logger.error('Unexpected error during weather fetch', e, stack);
      rethrow;
    }
  }
}

lib/src/features/journal/data/models/journal_entry.dart:
import 'package:drift/drift.dart';

import '../../../../core/database/database.dart';

/// A domain-level model for a journal entry, independent of the storage layer.
///
/// This entity represents the core data structure used throughout the application's
/// UI and business logic, decoupling it from the specific database implementation (Drift).
class JournalEntry {
  /// The unique identifier of the entry (nullable for new, unsaved entries).
  final int? id;

  /// The timestamp representing the date of the journal entry.
  final DateTime date;

  /// The local filesystem path to the high-resolution photo.
  final String photoPath;

  /// The local filesystem path to the optimized thumbnail (optional).
  final String? thumbnailPath;

  /// The user's mood rating for the day (typically 1-5).
  final int moodRating;

  /// An optional text note describing the day's events.
  final String? note;

  /// The location name where the entry was created (optional).
  final String? location;

  /// The formatted temperature string (e.g., "24°C") (optional).
  final String? weatherTemp;

  /// The icon code representing the weather condition (optional).
  final String? weatherIcon;

  /// Creates a [JournalEntry] instance.
  JournalEntry({
    this.id,
    required this.date,
    required this.photoPath,
    this.thumbnailPath,
    required this.moodRating,
    this.note,
    this.location,
    this.weatherTemp,
    this.weatherIcon,
  });

  /// Converts a Drift database row [DayEntry] into a domain [JournalEntry].
  ///
  /// This factory method handles the mapping from the persistence layer's
  /// data structure to the application's domain entity.
  factory JournalEntry.fromDrift(DayEntry entry) {
    return JournalEntry(
      id: entry.id,
      date: entry.date,
      photoPath: entry.photoPath,
      thumbnailPath: entry.thumbnailPath,
      moodRating: entry.moodRating,
      note: entry.note,
      location: entry.location,
      weatherTemp: entry.weatherTemp,
      weatherIcon: entry.weatherIcon,
    );
  }

  /// Converts this domain model into a Drift companion object.
  ///
  /// This method prepares the data for database insertion or updates,
  /// handling the conversion of nullable fields to [Value] types required by Drift.
  DayEntriesCompanion toDriftCompanion() {
    return DayEntriesCompanion(
      id: id != null ? Value(id!) : const Value.absent(),
      date: Value(date),
      photoPath: Value(photoPath),
      thumbnailPath: Value(thumbnailPath),
      moodRating: Value(moodRating),
      note: Value(note),
      location: Value(location),
      weatherTemp: Value(weatherTemp),
      weatherIcon: Value(weatherIcon),
    );
  }
}

lib/src/features/journal/data/sources/quote_service.dart:
import 'dart:convert';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http/http.dart' as http;

import '../../../../core/utils/logger_service.dart';
import '../../domain/models/quote.dart';

/// Provides a singleton instance of the [http.Client].
///
/// This provider allows for easy dependency injection and mocking of the
/// HTTP client during unit testing.
final httpClientProvider = Provider((ref) => http.Client());

/// Provides the [QuoteService] instance.
final quoteServiceProvider = Provider((ref) {
  return QuoteService(ref.watch(httpClientProvider));
});

/// Asynchronously fetches the daily quote.
///
/// This provider manages the state of the quote fetching operation,
/// returning a [Future] that resolves to a [Quote] object.
final quoteProvider = FutureProvider<Quote>((ref) async {
  final service = ref.watch(quoteServiceProvider);
  return service.fetchDailyQuote();
});

/// Service responsible for fetching inspirational quotes from an external API.
class QuoteService {
  final http.Client _client;
  static const _apiUrl = 'https://zenquotes.io/api/today';

  /// Creates a [QuoteService] with the injected HTTP client.
  QuoteService(this._client);

  /// Fetches the quote of the day from the remote API.
  ///
  /// Implements a fallback mechanism: if the API call fails due to network
  /// issues or returns a non-200 status code, a default [Quote.fallback]
  /// is returned to ensure the UI always has content to display.
  Future<Quote> fetchDailyQuote() async {
    try {
      Logger.debug('Initiating daily quote fetch from $_apiUrl');

      final response = await _client
          .get(Uri.parse(_apiUrl))
          .timeout(const Duration(seconds: 5));

      if (response.statusCode == 200) {
        final List<dynamic> data = jsonDecode(response.body);
        if (data.isNotEmpty) {
          Logger.info('Daily quote fetched successfully.');
          return Quote.fromJson(data[0]);
        }
      }

      Logger.warning(
        'Quote API returned status ${response.statusCode} or empty data. Using fallback.',
      );
      return Quote.fallback;
    } catch (e, stack) {
      // Log as a warning since this is a handled error that doesn't crash the app.
      Logger.warning(
        'Failed to fetch daily quote (Network/Timeout). Returning fallback.',
        e,
        stack,
      );
      return Quote.fallback;
    }
  }
}

lib/src/core/utils/thumbnail/thumbnail_service.dart:
import 'dart:io';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import '../logger_service.dart';

/// A service dedicated to the creation and management of image thumbnails.
///
/// Encapsulates compression logic and filesystem paths for thumbnails,
/// keeping this responsibility separate from other image services.
class ThumbnailService {
  /// Generates a WebP thumbnail for a given image file.
  ///
  /// Returns the path to the generated thumbnail or null on failure.
  /// Includes existence checks to prevent [PathNotFoundException].
  Future<String?> generateThumbnail(String originalPath, {int width = 300, int quality = 85}) async {
    try {
      final sourceFile = File(originalPath);

      if (!await sourceFile.exists()) {
        Logger.warning('ThumbnailService: Source file missing at $originalPath');
        return null;
      }

      final dir = await getApplicationSupportDirectory();
      final thumbsDir = Directory(p.join(dir.path, 'thumbnails'));

      if (!await thumbsDir.exists()) {
        await thumbsDir.create(recursive: true);
      }

      final base = p.basenameWithoutExtension(originalPath);
      final outPath = p.join(thumbsDir.path, '${base}_thumb.webp');

      if (await File(outPath).exists()) {
        return outPath;
      }

      final XFile? compressed = await FlutterImageCompress.compressAndGetFile(
        originalPath,
        outPath,
        minWidth: width,
        quality: quality,
        format: CompressFormat.webp,
      );

      return compressed?.path;
    } catch (e, stack) {
      Logger.error('Thumbnail generation failed', e, stack);
      return null;
    }
  }
}


lib/src/features/journal/data/journal_repository.dart:
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/database/database.dart';
import '../../../core/utils/image_service.dart';
import '../../../core/utils/logger_service.dart';
import '../../../core/utils/thumbnail/thumbnail_service.dart';
import 'models/journal_entry.dart';

/// Provides a singleton instance of the [ImageService].
final imageServiceProvider = Provider<ImageService>((ref) => ImageService());

/// Provides a singleton instance of the [ThumbnailService].
final thumbnailServiceProvider = Provider<ThumbnailService>((ref) => ThumbnailService());

/// Provides the [JournalRepository] for interacting with journal data.
///
/// This provider acts as the single source of truth for journal operations,
/// combining database access with file system management.
final journalRepositoryProvider = Provider<JournalRepository>((ref) {
  return JournalRepository(
    db: ref.watch(databaseProvider),
    imageService: ref.watch(imageServiceProvider),
    thumbnailService: ref.watch(thumbnailServiceProvider),
  );
});

/// Manages the data persistence and file handling for Journal Entries.
///
/// This repository abstracts the complexity of coordinating SQLite database
/// operations (via Drift) with physical file management (images and thumbnails).
class JournalRepository {
  final AppDatabase _db;
  final ImageService _imageService;
  final ThumbnailService _thumbnailService;

  /// Creates a [JournalRepository] with required dependencies.
  JournalRepository({
    required AppDatabase db,
    required ImageService imageService,
    required ThumbnailService thumbnailService,
  })  : _db = db,
        _imageService = imageService,
        _thumbnailService = thumbnailService;

  /// Persists a new journal entry and handles image optimization.
  ///
  /// This method performs three key steps:
  /// 1. Optimizes the temporary image file to WebP format for permanent storage.
  /// 2. Generates a thumbnail for performance optimization in lists.
  /// 3. Inserts the metadata and file paths into the database.
  ///
  /// Throws an [Exception] if the primary image processing fails.
  Future<void> addEntry(JournalEntry entry, String tempPath, {bool deleteSource = false}) async {
    Logger.info('Attempting to add new journal entry...');

    // 1. Process the main image (WebP, quality 85)
    // Returns the PERMANENT path (e.g., .../krono_123.webp)
    final optimizedPath = await _imageService.processAndOptimizeImage(tempPath, deleteSource: deleteSource);

    if (optimizedPath == null) {
      const error = "Failed to process and optimize the primary image.";
      Logger.error(error, Exception(error), StackTrace.current);
      throw Exception(error);
    }

    // 2. Generate the thumbnail from the PERMANENT path
    final thumbPath = await _thumbnailService.generateThumbnail(optimizedPath, width: 300);

    // 3. Save to database
    final companion = entry.toDriftCompanion().copyWith(
      photoPath: Value(optimizedPath),
      thumbnailPath: Value(thumbPath),
      date: Value(entry.date),
    );

    await _db.into(_db.dayEntries).insert(companion);
    Logger.info('Journal entry successfully added to database.');
  }

  /// Updates an existing journal entry, handling potential image replacement.
  ///
  /// If [newTempPath] is provided, the old image and thumbnail are deleted from
  /// the filesystem, and new assets are generated and linked.
  Future<void> updateEntry(JournalEntry entry, {String? newTempPath, bool deleteSource = false}) async {
    if (entry.id == null) {
      throw Exception('Entry ID is required for update operations.');
    }

    Logger.info('Updating journal entry ID: ${entry.id}');

    final existingRow = await (_db.select(_db.dayEntries)
      ..where((t) => t.id.equals(entry.id!)))
        .getSingleOrNull();

    if (existingRow == null) {
      throw Exception('Entry not found in database.');
    }

    String finalPhotoPath = existingRow.photoPath;
    String? finalThumbPath = existingRow.thumbnailPath;

    // Check if the user has replaced the photo
    if (newTempPath != null && newTempPath != existingRow.photoPath) {
      Logger.debug('Image replacement detected. Processing new image...');

      // A. Process the new image
      final processed =
      await _imageService.processAndOptimizeImage(newTempPath, deleteSource: deleteSource);

      if (processed != null) {
        // B. Cleanup old files to prevent storage bloat
        await _imageService.deleteFile(existingRow.photoPath);
        if (existingRow.thumbnailPath != null) {
          await _imageService.deleteFile(existingRow.thumbnailPath!);
        }

        finalPhotoPath = processed;

        // C. Generate new thumbnail
        finalThumbPath = await _thumbnailService.generateThumbnail(processed, width: 300);
      }
    }

    final companion = entry.toDriftCompanion().copyWith(
      photoPath: Value(finalPhotoPath),
      thumbnailPath: Value(finalThumbPath),
    );

    await (_db.update(_db.dayEntries)..where((t) => t.id.equals(entry.id!)))
        .write(companion);
    Logger.info('Journal entry ID ${entry.id} updated successfully.');
  }

  /// Permanently removes a journal entry and its associated media files.
  Future<void> deleteEntry(JournalEntry entry) async {
    Logger.info('Deleting journal entry ID: ${entry.id}');

    // Remove physical files
    await _imageService.deleteFile(entry.photoPath);
    if (entry.thumbnailPath != null) {
      await _imageService.deleteFile(entry.thumbnailPath!);
    }

    // Remove database record
    if (entry.id != null) {
      await (_db.delete(_db.dayEntries)..where((t) => t.id.equals(entry.id!)))
          .go();
    }
  }

  /// Retrieves all journal entries sorted by date (newest first).
  Future<List<JournalEntry>> getAllEntries() async {
    final rows = await (_db.select(_db.dayEntries)
      ..orderBy([(t) => OrderingTerm.desc(t.date)]))
        .get();

    return rows.map((row) => JournalEntry.fromDrift(row)).toList();
  }

  /// Destructive operation: Deletes ALL journal data and files.
  ///
  /// Use with caution. This wipes the `dayEntries` table and clears the
  /// associated images from the filesystem.
  Future<void> deleteAllData() async {
    Logger.warning('Initiating complete data wipe (deleteAllData).');

    final rows = await _db.select(_db.dayEntries).get();
    for (final r in rows) {
      await _imageService.deleteFile(r.photoPath);
      if (r.thumbnailPath != null) {
        await _imageService.deleteFile(r.thumbnailPath!);
      }
    }
    await _db.delete(_db.dayEntries).go();
    Logger.info('All journal data and files have been deleted.');
  }
}

lib/src/features/journal/domain/models/quote.dart:
import 'package:flutter/foundation.dart';

/// A domain model representing an inspirational quote.
///
/// This class is used to display daily motivation to the user, typically fetched
/// from an external API (e.g., ZenQuotes).
@immutable
class Quote {
  /// The actual text content of the quote.
  final String text;

  /// The name of the author attributed to the quote.
  final String author;

  /// Creates a constant [Quote] instance.
  const Quote({required this.text, required this.author});

  /// Creates a [Quote] instance from a JSON map.
  ///
  /// Designed to parse responses from the ZenQuotes API, where 'q' represents
  /// the quote text and 'a' represents the author.
  ///
  /// Returns a valid object with default values if specific keys are missing,
  /// ensuring the UI does not crash on malformed data.
  factory Quote.fromJson(Map<String, dynamic> json) {
    return Quote(
      text: json['q'] as String? ?? '',
      author: json['a'] as String? ?? 'Unknown',
    );
  }

  /// A fallback quote used when the network is unavailable or the API fails.
  static const fallback = Quote(
    text: "The best way to predict the future is to create it.",
    author: "Peter Drucker",
  );

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
          other is Quote &&
              runtimeType == other.runtimeType &&
              text == other.text &&
              author == other.author;

  @override
  int get hashCode => text.hashCode ^ author.hashCode;

  @override
  String toString() => 'Quote(text: $text, author: $author)';
}

lib/src/features/journal/presentation/widgets/camera/widgets/camera_preview_layer.dart:
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';

import 'camera_ui_elements.dart';

/// A dedicated widget for rendering the camera preview stream and interactive overlays.
///
/// This component separates the rendering logic from the business logic of the
/// main camera screen. It is responsible for:
/// 1. Displaying the raw [CameraPreview] with a specific aspect ratio.
/// 2. Capturing gestures for focus (tap) and zoom (pinch).
/// 3. Rendering visual overlays such as the composition grid and focus/exposure UI.
class CameraPreviewLayer extends StatelessWidget {
  /// The controller managing the camera session.
  final CameraController? controller;

  /// Whether to display the rule-of-thirds grid overlay.
  final bool isGridEnabled;

  // --- Gesture Callbacks ---

  /// Callback triggered when a scale (pinch) gesture begins.
  final void Function(ScaleStartDetails) onScaleStart;

  /// Callback triggered when a scale (pinch) gesture updates.
  final void Function(ScaleUpdateDetails) onScaleUpdate;

  /// Callback triggered on a tap up event (used for focusing).
  final void Function(Offset, BoxConstraints) onTapUp;

  /// Callback triggered on a long press start (used for locking focus).
  final void Function(Offset, BoxConstraints) onLongPressStart;

  // --- Focus UI State ---

  /// The current screen coordinates of the focus point.
  final Offset? focusPoint;

  /// Whether the focus ring and exposure slider should be visible.
  final bool showFocusUI;

  /// Whether the focus/exposure is currently locked (AE/AF Lock).
  final bool isFocusLocked;

  /// Animation controller for the focus ring scaling effect.
  final Animation<double>? focusScaleAnimation;

  /// The current exposure offset value (EV).
  final double currentExposureOffset;

  /// The maximum allowed exposure offset for the UI slider.
  final double uiExposureLimit;

  /// Callback triggered when the exposure slider value changes.
  final ValueChanged<double> onExposureChanged;

  const CameraPreviewLayer({
    super.key,
    required this.controller,
    required this.isGridEnabled,
    required this.onScaleStart,
    required this.onScaleUpdate,
    required this.onTapUp,
    required this.onLongPressStart,
    required this.focusPoint,
    required this.showFocusUI,
    required this.isFocusLocked,
    required this.focusScaleAnimation,
    required this.currentExposureOffset,
    required this.uiExposureLimit,
    required this.onExposureChanged,
  });

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    // Enforce a 3:4 aspect ratio, which is the standard format for photography.
    final targetHeight = screenWidth / (3 / 4);

    return Align(
      // Slightly offset upwards (-0.15) to reserve space for bottom controls.
      alignment: const Alignment(0, -0.15),
      child: SizedBox(
        width: screenWidth,
        height: targetHeight,
        child: ClipRect(
          child: LayoutBuilder(builder: (context, constraints) {
            final isCameraReady =
                controller != null && controller!.value.isInitialized;

            return Stack(
              fit: StackFit.expand,
              children: [
                // Layer 1: Camera Preview Stream
                if (isCameraReady)
                  FittedBox(
                    fit: BoxFit.cover,
                    child: SizedBox(
                      width: constraints.maxWidth,
                      // Use the actual aspect ratio of the camera sensor to prevent distortion.
                      height:
                      constraints.maxWidth * controller!.value.aspectRatio,
                      child: Transform(
                        alignment: Alignment.center,
                        transform: Matrix4.identity(),
                        child: CameraPreview(controller!),
                      ),
                    ),
                  )
                else
                  Container(color: Colors.black),

                // Layer 2: Gesture Detector (Zoom, Focus)
                if (isCameraReady)
                  GestureDetector(
                    behavior: HitTestBehavior.opaque,
                    onScaleStart: onScaleStart,
                    onScaleUpdate: onScaleUpdate,
                    onTapUp: (d) => onTapUp(d.localPosition, constraints),
                    onLongPressStart: (d) =>
                        onLongPressStart(d.localPosition, constraints),
                  ),

                // Layer 3: Grid Overlay
                if (isGridEnabled)
                  IgnorePointer(
                    child: CustomPaint(
                      size: Size.infinite,
                      painter: GridPainter(),
                    ),
                  ),

                // Layer 4: Focus & Exposure UI
                if (showFocusUI && focusPoint != null && isCameraReady) ...[
                  // Focus Ring
                  Positioned(
                    left: focusPoint!.dx - 50,
                    top: focusPoint!.dy - 50,
                    width: 100,
                    height: 100,
                    child: IgnorePointer(
                      child: ScaleTransition(
                        scale: focusScaleAnimation!,
                        child: CustomPaint(
                          painter: FocusOverlayPainter(
                            focusPoint: const Offset(50, 50),
                            isLocked: isFocusLocked,
                          ),
                        ),
                      ),
                    ),
                  ),

                  // Exposure Slider
                  Builder(builder: (context) {
                    // Determine if the slider should appear above or below the focus ring
                    // to avoid being cut off by the screen edge.
                    final bool showAbove =
                        focusPoint!.dy > constraints.maxHeight * 0.85;
                    return Positioned(
                      left: focusPoint!.dx - 55,
                      top:
                      showAbove ? focusPoint!.dy - 80 : focusPoint!.dy + 55,
                      child: ScaleTransition(
                        scale: focusScaleAnimation!,
                        child: SizedBox(
                          width: 110,
                          height: 40,
                          child: SplitTrackSlider(
                            value: currentExposureOffset,
                            min: -uiExposureLimit,
                            max: uiExposureLimit,
                            showSun: false,
                            onChanged: onExposureChanged,
                            onChangeEnd: (_) {},
                          ),
                        ),
                      ),
                    );
                  }),
                ]
              ],
            );
          }),
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/widgets/camera/widgets/camera_review_view.dart:
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../../../../../l10n/app_localizations.dart';
import '../../../../../../core/utils/logger_service.dart';
import 'camera_ui_elements.dart';

/// Displays the captured image for user approval before saving.
///
/// This screen handles two states:
/// 1. **Processing:** Shows a loading indicator while the image is being optimized/saved in the background.
/// 2. **Review:** Displays the final image file, allowing the user to either discard (Retake) or confirm (Save).
class CameraReviewView extends StatelessWidget {
  /// The absolute path to the image file to be displayed.
  final String filePath;

  /// Callback triggered when the user chooses to discard the current image.
  final VoidCallback onRetake;

  /// Callback triggered when the user confirms the image.
  final VoidCallback onSave;

  /// The accent color used for the primary action button (Save).
  final Color primaryColor;

  /// Indicates whether the background image processing is still active.
  final bool isProcessing;

  /// Optional key to force the [Image] widget to rebuild/reload when the file changes.
  final Key? imageKey;

  const CameraReviewView({
    super.key,
    required this.filePath,
    required this.onRetake,
    required this.onSave,
    required this.primaryColor,
    this.isProcessing = false,
    this.imageKey,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: Colors.black,
      body: Stack(
        fit: StackFit.expand,
        children: [
          if (isProcessing)
            Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const CircularProgressIndicator(),
                  const SizedBox(height: 12),
                  Text(
                    l10n.processing,
                    style: theme.textTheme.bodyMedium
                        ?.copyWith(color: Colors.white70),
                  ),
                ],
              ),
            )
          else
            Center(
              child: Image.file(
                File(filePath),
                key: imageKey,
                fit: BoxFit.contain,
                gaplessPlayback: true,
                errorBuilder: (context, error, stackTrace) {
                  // Log the visual failure to Crashlytics without crashing the app.
                  Logger.warning(
                    'Failed to render review image from path: $filePath',
                    error,
                    stackTrace,
                  );

                  return Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.broken_image,
                          color: Colors.white, size: 64),
                      const SizedBox(height: 12),
                      Text(
                        l10n.imageLoadError,
                        style: theme.textTheme.bodyMedium
                            ?.copyWith(color: Colors.white70),
                      ),
                    ],
                  );
                },
              ),
            ),

          // Bottom gradient to increase contrast for action buttons against the image.
          Align(
            alignment: Alignment.bottomCenter,
            child: Container(
              height: 200,
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.bottomCenter,
                  end: Alignment.topCenter,
                  colors: [Colors.black87, Colors.transparent],
                ),
              ),
            ),
          ),

          Positioned(
            bottom: 60,
            left: 40,
            right: 40,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextActionButton(
                  icon: Icons.refresh_rounded,
                  label: l10n.retake,
                  onTap: onRetake,
                ),
                TextActionButton(
                  icon: Icons.check_circle_rounded,
                  label: l10n.save,
                  color: primaryColor,
                  isPrimary: true,
                  onTap: onSave,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

lib/src/features/journal/presentation/widgets/camera/widgets/camera_ui_elements.dart:
import 'package:flutter/material.dart';

// --- BUTTONS ---

/// The primary trigger button for the camera.
///
/// Displays a circular shutter button that transforms into a loading indicator
/// when [isRecording] is true.
class ShutterButton extends StatelessWidget {
  /// Indicates if a capture or processing operation is currently in progress.
  ///
  /// When true, the button displays a [CircularProgressIndicator].
  /// When false, it displays the standard white shutter circle.
  final bool isRecording;

  const ShutterButton({super.key, required this.isRecording});

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      height: 80,
      width: 80,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: Colors.white, width: 5),
        color: Colors.white.withValues(alpha: 0.2),
      ),
      child: Center(
        child: isRecording
            ? const SizedBox(
          height: 32,
          width: 32,
          child: CircularProgressIndicator(
            color: Colors.white,
            strokeWidth: 3,
          ),
        )
            : AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          height: 64,
          width: 64,
          decoration: BoxDecoration(
            color: Colors.white,
            // Currently configured for photo mode (circle).
            // If video mode is added later, this radius can be animated to 4.0.
            borderRadius: BorderRadius.circular(50),
          ),
        ),
      ),
    );
  }
}

/// A circular button with a semi-transparent "frosted glass" background.
///
/// Used for secondary camera controls like flash toggle or camera switch.
class GlassIconButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  final Color color;
  final double size;

  const GlassIconButton({
    super.key,
    required this.icon,
    required this.onTap,
    this.color = Colors.white,
    this.size = 44,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(size / 2),
        child: Container(
          width: size,
          height: size,
          color: Colors.black.withValues(alpha: 0.3),
          child: Icon(icon, color: color, size: size * 0.55),
        ),
      ),
    );
  }
}

/// A vertical layout button containing an icon and a text label.
///
/// Primarily used in the post-capture review screen for "Retake" or "Save" actions.
class TextActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;
  final Color color;

  /// If true, the button uses the [color] as its background to emphasize the primary action.
  final bool isPrimary;

  const TextActionButton({
    super.key,
    required this.icon,
    required this.label,
    required this.onTap,
    this.color = Colors.white,
    this.isPrimary = false,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: isPrimary ? color : Colors.white.withValues(alpha: 0.2),
              shape: BoxShape.circle,
            ),
            child: Icon(icon, color: Colors.white, size: 32),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }
}

// --- PAINTERS ---

/// Paints a "Rule of Thirds" grid overlay on the camera preview.
class GridPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withValues(alpha: 0.3)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    // Draw vertical lines
    for (var i = 1; i < 3; i++) {
      canvas.drawLine(
        Offset(size.width * i / 3, 0),
        Offset(size.width * i / 3, size.height),
        paint,
      );
      // Draw horizontal lines
      canvas.drawLine(
        Offset(0, size.height * i / 3),
        Offset(size.width, size.height * i / 3),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter old) => false;
}

/// Renders the visual feedback for focus and exposure locking.
///
/// Draws a ring at the [focusPoint] and optionally a lock icon if [isLocked] is true.
class FocusOverlayPainter extends CustomPainter {
  final Offset focusPoint;
  final bool isLocked;
  final bool showInnerDot;

  FocusOverlayPainter({
    required this.focusPoint,
    required this.isLocked,
    this.showInnerDot = true,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final color = isLocked ? Colors.yellow : Colors.white;

    final strokePaint = Paint()
      ..color = color.withValues(alpha: 0.8)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.5;

    final fillPaint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    // Draw the main focus ring
    canvas.drawCircle(focusPoint, 35, strokePaint);

    if (showInnerDot) {
      canvas.drawCircle(focusPoint, 4.0, fillPaint);
    }

    // Draw the lock indicator if focus/exposure is locked
    if (isLocked) {
      canvas.drawCircle(
        Offset(focusPoint.dx, focusPoint.dy - 40),
        10,
        Paint()..color = Colors.yellow,
      );

      final textPainter = TextPainter(
        text: TextSpan(
          text: String.fromCharCode(Icons.lock_rounded.codePoint),
          style: TextStyle(
            fontSize: 12,
            fontFamily: Icons.lock_rounded.fontFamily,
            color: Colors.black,
            package: Icons.lock_rounded.fontPackage,
          ),
        ),
        textDirection: TextDirection.ltr,
      )..layout();

      textPainter.paint(canvas, Offset(focusPoint.dx - 6, focusPoint.dy - 46));
    }
  }

  @override
  bool shouldRepaint(covariant FocusOverlayPainter old) =>
      old.focusPoint != focusPoint || old.isLocked != isLocked;
}

// --- SLIDER COMPONENTS ---

/// A custom slider widget designed for exposure compensation control.
///
/// Uses a minimal visual style with a split track and a sun-like thumb.
class SplitTrackSlider extends StatelessWidget {
  final double value;
  final double min;
  final double max;
  final bool showSun;
  final ValueChanged<double> onChanged;
  final ValueChanged<double>? onChangeEnd;

  const SplitTrackSlider({
    super.key,
    required this.value,
    required this.min,
    required this.max,
    required this.showSun,
    required this.onChanged,
    this.onChangeEnd,
  });

  @override
  Widget build(BuildContext context) {
    return SliderTheme(
      data: SliderThemeData(
        trackHeight: 1.5,
        thumbShape: const MinimalSunThumbShape(),
        trackShape: SplitTrackShape(showSun: showSun),
        overlayShape: SliderComponentShape.noOverlay,
        activeTrackColor: Colors.white,
        inactiveTrackColor: Colors.white.withValues(alpha: 0.5),
        thumbColor: Colors.white,
      ),
      child: Slider(
        value: value,
        min: min,
        max: max,
        onChanged: onChanged,
        onChangeEnd: onChangeEnd,
      ),
    );
  }
}

/// A custom track shape for the slider that draws a simple line.
class SplitTrackShape extends SliderTrackShape {
  final bool showSun;
  const SplitTrackShape({this.showSun = false});

  @override
  Rect getPreferredRect({
    required RenderBox parentBox,
    Offset offset = Offset.zero,
    required SliderThemeData sliderTheme,
    bool isEnabled = false,
    bool isDiscrete = false,
  }) {
    final double trackHeight = sliderTheme.trackHeight!;
    return Rect.fromLTWH(
      offset.dx,
      offset.dy + (parentBox.size.height - trackHeight) / 2,
      parentBox.size.width,
      trackHeight,
    );
  }

  @override
  void paint(
      PaintingContext context,
      Offset offset, {
        required RenderBox parentBox,
        required SliderThemeData sliderTheme,
        required Animation<double> enableAnimation,
        required TextDirection textDirection,
        required Offset thumbCenter,
        bool isEnabled = false,
        bool isDiscrete = false,
        Offset? secondaryOffset,
      }) {
    final Paint paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    context.canvas.drawLine(
      Offset(offset.dx, thumbCenter.dy),
      Offset(offset.dx + parentBox.size.width, thumbCenter.dy),
      paint,
    );
  }
}

/// A custom thumb shape for the slider, rendered as a small filled circle.
class MinimalSunThumbShape extends SliderComponentShape {
  const MinimalSunThumbShape();

  @override
  Size getPreferredSize(bool isEnabled, bool isDiscrete) => const Size(20, 20);

  @override
  void paint(
      PaintingContext context,
      Offset center, {
        required Animation<double> activationAnimation,
        required Animation<double> enableAnimation,
        required bool isDiscrete,
        required TextPainter labelPainter,
        required RenderBox parentBox,
        required SliderThemeData sliderTheme,
        required TextDirection textDirection,
        required double value,
        required double textScaleFactor,
        required Size sizeWithOverflow,
      }) {
    context.canvas.drawCircle(
      center,
      7.0,
      Paint()
        ..color = Colors.white
        ..style = PaintingStyle.fill,
    );
  }
}

lib/src/features/journal/presentation/widgets/camera/custom_camera_screen.dart:
import 'dart:async';
import 'dart:math' as math;

import 'package:camera/camera.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../../../core/utils/logger_service.dart';
import 'image_processor.dart';
import 'widgets/camera_preview_layer.dart';
import 'widgets/camera_review_view.dart';
import 'widgets/camera_ui_elements.dart';

/// A production-grade custom camera screen.
///
/// Features:
/// - Photo capture with optional timer.
/// - Zoom control (pinch-to-zoom and presets).
/// - Tap-to-focus and exposure adjustment.
/// - Front/Back camera switching.
/// - Grid overlay toggle.
/// - Volume button shutter trigger.
class CustomCameraScreen extends StatefulWidget {
  const CustomCameraScreen({super.key});

  @override
  State<CustomCameraScreen> createState() => _CustomCameraScreenState();
}

class _CustomCameraScreenState extends State<CustomCameraScreen>
    with WidgetsBindingObserver, TickerProviderStateMixin {
  // --- Camera Controllers & Config ---
  CameraController? _controller;
  CameraDescription? _mainBackCamera;
  CameraDescription? _mainFrontCamera;

  // --- State Flags ---
  bool _isUsingFrontCamera = false;
  bool _isSwitching = false;
  bool _isFlashOn = false;
  bool _isTakingPicture = false;
  bool _isGridEnabled = false;
  bool _isProcessingImage = false;

  // --- Capture Data ---
  XFile? _capturedFile;
  Key? _reviewImageKey;

  // --- Timer State ---
  int _timerDuration = 0;
  int _currentCountdown = 0;
  bool _isCountingDown = false;
  Timer? _countdownTimer;

  // --- Zoom State ---
  double _minAvailableZoom = 1.0;
  double _maxAvailableZoom = 1.0;
  double _currentZoomLevel = 1.0;
  double _baseScale = 1.0;
  List<double> _zoomPresets = [];
  bool _showZoomLabel = false;
  Timer? _zoomLabelTimer;
  AnimationController? _zoomAnimationController;
  Animation<double>? _zoomAnimation;

  // --- Focus & Exposure State ---
  Offset? _focusPoint;
  bool _showFocusUI = false;
  bool _isFocusLocked = false;
  Timer? _focusTimer;
  Timer? _exposureTimer;
  double _currentExposureOffset = 0.0;
  double _uiExposureLimit = 1.0;

  AnimationController? _focusAnimationController;
  Animation<double>? _focusScaleAnimation;

  // --- UI Animations ---
  double _shutterOpacity = 0.0;

  // --- Hardware Events ---
  static const MethodChannel _volumeChannel =
  MethodChannel('com.yourapp.volume');

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Hide system UI for immersive experience
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
    ServicesBinding.instance.keyboard.addHandler(_onKey);
    _volumeChannel.setMethodCallHandler(_handleNativeMethodCall);

    _focusAnimationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _focusScaleAnimation = Tween<double>(begin: 1.3, end: 1.0).animate(
      CurvedAnimation(
          parent: _focusAnimationController!, curve: Curves.easeOutBack),
    );

    _loadGridState();
    _initCamera();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    // Restore system UI
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);
    ServicesBinding.instance.keyboard.removeHandler(_onKey);
    _volumeChannel.setMethodCallHandler(null);

    _countdownTimer?.cancel();
    _zoomLabelTimer?.cancel();
    _focusTimer?.cancel();
    _exposureTimer?.cancel();
    _zoomAnimationController?.dispose();
    _focusAnimationController?.dispose();

    _controller?.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final CameraController? cameraController = _controller;
    if (cameraController == null || !cameraController.value.isInitialized) {
      return;
    }

    if (state == AppLifecycleState.inactive) {
      Logger.debug('App inactive, disposing camera controller.');
      cameraController.dispose();
    } else if (state == AppLifecycleState.resumed) {
      Logger.debug('App resumed, re-initializing camera.');
      _initCamera();
    }
  }

  /// Loads the user's preference for the grid overlay.
  Future<void> _loadGridState() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _isGridEnabled = prefs.getBool('isGridEnabled') ?? false);
  }

  /// Toggles the grid overlay and persists the preference.
  Future<void> _toggleGrid() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _isGridEnabled = !_isGridEnabled;
    });
    await prefs.setBool('isGridEnabled', _isGridEnabled);
  }

  /// Initializes available cameras and selects the best starting camera.
  Future<void> _initCamera() async {
    try {
      Logger.info('Initializing camera system...');
      final cameras = await availableCameras();
      if (cameras.isEmpty) {
        Logger.error(
            'No cameras found on device.', Exception('No cameras'), StackTrace.current);
        _showErrorDialog("No cameras found on this device.");
        return;
      }

      _mainBackCamera = _selectPreferredBackCamera(cameras);
      try {
        _mainFrontCamera =
            cameras.firstWhere((c) => c.lensDirection == CameraLensDirection.front);
      } catch (_) {
        Logger.warning('No front camera found.');
        _mainFrontCamera = null;
      }

      if (_mainBackCamera != null) {
        await _startCamera(_mainBackCamera!);
        _isUsingFrontCamera = false;
      } else if (_mainFrontCamera != null) {
        await _startCamera(_mainFrontCamera!);
        _isUsingFrontCamera = true;
      }
    } on CameraException catch (e, stack) {
      _handleCameraException(e, stack);
    } catch (e, stack) {
      Logger.error('Unexpected error during camera init', e, stack);
    }
  }

  /// Handles platform-specific camera exceptions.
  void _handleCameraException(CameraException e, StackTrace stack) {
    Logger.error('CameraException: ${e.code}', e, stack);
    if (e.code == 'CameraAccessDenied' || e.code == 'permissionNotGranted') {
      _showPermissionDialog();
    } else {
      _showErrorDialog("Camera error: ${e.description}");
    }
  }

  /// Prompts the user to grant camera permissions via system settings.
  void _showPermissionDialog() {
    if (!mounted) return;
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text("Camera Permission Required"),
        content:
        const Text("Krono needs camera access to capture your memories."),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Cancel")),
          TextButton(
              onPressed: () {
                Navigator.pop(context);
                openAppSettings();
              },
              child: const Text("Settings")),
        ],
      ),
    );
  }

  void _showErrorDialog(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Colors.red));
  }

  /// Selects the best back camera, avoiding ultra-wide or macro lenses if possible.
  CameraDescription _selectPreferredBackCamera(List<CameraDescription> cams) {
    final backs =
    cams.where((c) => c.lensDirection == CameraLensDirection.back).toList();
    if (backs.isEmpty) return cams.first;

    // Filter out auxiliary lenses based on common naming conventions
    final regexAux =
    RegExp(r'ultra|wide|0\.5|macro|tele', caseSensitive: false);
    final mainCandidates =
    backs.where((c) => !regexAux.hasMatch(c.name.toLowerCase())).toList();

    if (mainCandidates.isNotEmpty) return mainCandidates.first;
    return backs.first;
  }

  /// Configures and starts the camera stream.
  Future<void> _startCamera(CameraDescription camera) async {
    final oldController = _controller;
    if (oldController != null) {
      await oldController.dispose();
    }

    Logger.info('Starting camera: ${camera.name} (${camera.lensDirection})');

    final newController = CameraController(
      camera,
      ResolutionPreset.veryHigh,
      enableAudio: false,
      imageFormatGroup: ImageFormatGroup.jpeg,
    );

    _controller = newController;

    try {
      await newController.initialize();
      if (!mounted) return;

      // Apply initial settings
      await Future.wait([
        newController
            .setFlashMode(_isFlashOn ? FlashMode.always : FlashMode.off),
        newController.setExposureOffset(0.0),
      ]);

      // Configure Zoom
      _minAvailableZoom = await newController.getMinZoomLevel();
      _maxAvailableZoom = await newController.getMaxZoomLevel();
      _zoomPresets =
          _computeFixedZoomPresets(_minAvailableZoom, _maxAvailableZoom);
      _currentZoomLevel = _minAvailableZoom.clamp(1.0, _maxAvailableZoom);
      await newController.setZoomLevel(_currentZoomLevel);

      // Configure Exposure Limits
      final minExp = await newController.getMinExposureOffset();
      final maxExp = await newController.getMaxExposureOffset();
      _uiExposureLimit = math.min(minExp.abs(), maxExp.abs());
      if (_uiExposureLimit == 0) _uiExposureLimit = 1.0;

      // Auto-focus for front camera if supported
      if (camera.lensDirection == CameraLensDirection.front) {
        try {
          await newController.setFocusMode(FocusMode.auto);
        } catch (_) {}
      }

      setState(() => _isSwitching = false);
    } on CameraException catch (e, stack) {
      _handleCameraException(e, stack);
      setState(() => _isSwitching = false);
    } catch (e, stack) {
      Logger.error('Generic error starting camera', e, stack);
      setState(() => _isSwitching = false);
    }
  }

  /// Toggles between front and back cameras.
  void _switchCamera() async {
    if (_mainBackCamera == null || _mainFrontCamera == null) return;
    if (_isSwitching) return;

    HapticFeedback.lightImpact();
    setState(() {
      _isSwitching = true;
      _controller = null;
      _isFocusLocked = false;
      _showFocusUI = false;
      _currentExposureOffset = 0.0;
    });

    // Small delay to allow UI to update before heavy camera operation
    await Future.delayed(const Duration(milliseconds: 50));

    if (_isUsingFrontCamera) {
      _isUsingFrontCamera = false;
      await _startCamera(_mainBackCamera!);
    } else {
      _isUsingFrontCamera = true;
      await _startCamera(_mainFrontCamera!);
    }
  }

  /// Initiates the capture flow, handling the timer if active.
  Future<void> _attemptTakePhoto() async {
    if (_isTakingPicture || _isCountingDown || _isProcessingImage) return;

    if (_timerDuration > 0) {
      Logger.info('Starting capture timer: $_timerDuration seconds');
      setState(() {
        _isCountingDown = true;
        _currentCountdown = _timerDuration;
      });
      _countdownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (!mounted) return timer.cancel();
        if (_currentCountdown > 1) {
          setState(() {
            _currentCountdown--;
            HapticFeedback.selectionClick();
          });
        } else {
          timer.cancel();
          setState(() => _isCountingDown = false);
          _takePicture();
        }
      });
    } else {
      _takePicture();
    }
  }

  /// Captures the image, pauses preview, and processes the file.
  Future<void> _takePicture() async {
    if (_controller == null ||
        !_controller!.value.isInitialized ||
        _isTakingPicture) {
      return;
    }

    HapticFeedback.heavyImpact();
    // Visual shutter effect
    if (mounted) setState(() => _shutterOpacity = 1.0);
    Future.delayed(const Duration(milliseconds: 100), () {
      if (mounted) setState(() => _shutterOpacity = 0.0);
    });

    try {
      setState(() {
        _isTakingPicture = true;
        _isProcessingImage = true;
      });

      Logger.info('Capturing image...');
      final XFile image = await _controller!.takePicture();
      await _controller!.pausePreview();

      // Offload image processing (mirroring, cropping) to a background isolate
      final processedPath = await compute(processAndSaveImage, {
        'path': image.path,
        'isFront': _isUsingFrontCamera,
        'aspect': 3 / 4,
        // Mirror the image if using front camera to match preview behavior
        'mirror': _isUsingFrontCamera,
      });

      if (!mounted) return;

      setState(() {
        _capturedFile = XFile(processedPath ?? image.path);
        _isTakingPicture = false;
        _isProcessingImage = false;
        // Force image widget refresh
        _reviewImageKey = ValueKey(DateTime.now().microsecondsSinceEpoch);
      });
      Logger.info('Image captured and processed successfully.');
    } catch (e, st) {
      Logger.error("Capture Error", e, st);
      _controller?.resumePreview();
      if (mounted) {
        setState(() {
          _isTakingPicture = false;
          _isProcessingImage = false;
        });
      }
    }
  }

  // --- Zoom Logic ---

  void _handleScaleUpdate(ScaleUpdateDetails details) async {
    if (_controller == null || !_controller!.value.isInitialized) return;
    double scale = _baseScale * details.scale;
    scale = scale.clamp(_minAvailableZoom, _maxAvailableZoom);
    if ((scale - _currentZoomLevel).abs() > 0.01) {
      setState(() {
        _currentZoomLevel = scale;
        _showZoomLabel = true;
      });
      _startZoomLabelTimer();
      try {
        await _controller!.setZoomLevel(scale);
      } catch (_) {}
    }
  }

  void _animateZoomTo(double target) {
    if (_controller == null || !_controller!.value.isInitialized) return;
    _zoomAnimationController?.dispose();
    _zoomAnimationController = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 300));
    final start = _currentZoomLevel;
    _zoomAnimation = Tween<double>(begin: start, end: target).animate(
        CurvedAnimation(
            parent: _zoomAnimationController!, curve: Curves.easeOut));
    setState(() => _showZoomLabel = true);
    _startZoomLabelTimer();
    _zoomAnimationController!.addListener(() {
      _controller?.setZoomLevel(_zoomAnimation!.value);
      if (mounted) setState(() => _currentZoomLevel = _zoomAnimation!.value);
    });
    _zoomAnimationController!.forward();
  }

  // --- Focus & Exposure Logic ---

  void _onTapToFocus(Offset localPosition, BoxConstraints constraints) {
    if (_controller == null || !_controller!.value.isInitialized) return;

    // Unlock if previously locked
    if (_isFocusLocked) {
      setState(() => _isFocusLocked = false);
      try {
        _controller!.setFocusMode(FocusMode.auto);
        _controller!.setExposureMode(ExposureMode.auto);
      } catch (_) {}
    }

    setState(() {
      _currentExposureOffset = 0.0;
      _focusPoint = localPosition;
      _showFocusUI = true;
    });

    _focusAnimationController?.reset();
    _focusAnimationController?.forward();

    try {
      _controller!.setExposureOffset(0.0);
    } catch (_) {}

    double nx = localPosition.dx / constraints.maxWidth;
    double ny = localPosition.dy / constraints.maxHeight;

    try {
      _controller!.setFocusPoint(Offset(nx, ny));
      _controller!.setExposurePoint(Offset(nx, ny));
    } catch (_) {}

    _startHideUITimers();
  }

  void _onLongPressFocus(Offset localPosition, BoxConstraints constraints) {
    if (_controller == null || !_controller!.value.isInitialized) return;
    HapticFeedback.heavyImpact();

    double nx = localPosition.dx / constraints.maxWidth;
    double ny = localPosition.dy / constraints.maxHeight;

    setState(() {
      _focusPoint = localPosition;
      _showFocusUI = true;
      _isFocusLocked = true;
    });

    _focusAnimationController?.reset();
    _focusAnimationController?.forward();

    try {
      _controller!.setFocusMode(FocusMode.auto);
      _controller!.setExposureMode(ExposureMode.auto);
      _controller!.setFocusPoint(Offset(nx, ny));
      _controller!.setExposurePoint(Offset(nx, ny));
    } catch (_) {}

    // Lock after a short delay to allow initial focus
    Future.delayed(const Duration(milliseconds: 400), () {
      if (!mounted || !_isFocusLocked) return;
      try {
        _controller!.setFocusMode(FocusMode.locked);
        _controller!.setExposureMode(ExposureMode.locked);
        Logger.debug('Focus and Exposure locked.');
      } catch (_) {}
    });

    _focusTimer?.cancel();
    _exposureTimer?.cancel();
  }

  @override
  Widget build(BuildContext context) {
    // If a photo is captured, show the review screen
    if (_capturedFile != null) {
      return CameraReviewView(
        filePath: _capturedFile!.path,
        primaryColor: Theme.of(context).colorScheme.primary,
        isProcessing: _isProcessingImage,
        imageKey: _reviewImageKey,
        onRetake: () async {
          setState(() => _capturedFile = null);
          await _controller?.resumePreview();
        },
        onSave: () => Navigator.pop(context, _capturedFile!.path),
      );
    }

    return Scaffold(
      backgroundColor: Colors.black,
      body: Stack(
        children: [
          // 1. Camera Preview & Interactive Layer
          CameraPreviewLayer(
            controller: _controller,
            isGridEnabled: _isGridEnabled,
            onScaleStart: (d) => _baseScale = _currentZoomLevel,
            onScaleUpdate: _handleScaleUpdate,
            onTapUp: _onTapToFocus,
            onLongPressStart: _onLongPressFocus,
            focusPoint: _focusPoint,
            showFocusUI: _showFocusUI,
            isFocusLocked: _isFocusLocked,
            focusScaleAnimation: _focusScaleAnimation,
            currentExposureOffset: _currentExposureOffset,
            uiExposureLimit: _uiExposureLimit,
            onExposureChanged: (v) {
              setState(() => _currentExposureOffset = v);
              _controller!.setExposureOffset(v);
              if (!_isFocusLocked) _startHideUITimers();
            },
          ),

          // 2. Shutter Flash Effect
          IgnorePointer(
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 100),
              curve: Curves.easeInOutQuad,
              color: Colors.black.withValues(alpha: _shutterOpacity),
              width: MediaQuery.of(context).size.width,
              height: MediaQuery.of(context).size.height,
            ),
          ),

          // 3. Zoom Controls
          Positioned(
              bottom: 120,
              left: 0,
              right: 0,
              child: Center(child: _buildZoomPresetRow())),

          if (_showZoomLabel)
            Positioned(
                bottom: 200,
                left: 0,
                right: 0,
                child: Center(
                    child: Container(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 6),
                        decoration: BoxDecoration(
                            color: Colors.black54,
                            borderRadius: BorderRadius.circular(20)),
                        child: Text(
                            "${_currentZoomLevel.toStringAsFixed(1)}x",
                            style: const TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold))))),

          // 4. Countdown Overlay
          if (_isCountingDown)
            Center(
                child: Text("$_currentCountdown",
                    style: const TextStyle(
                        color: Colors.white,
                        fontSize: 120,
                        fontWeight: FontWeight.bold))),

          // 5. Main UI Controls (Top & Bottom Bars)
          SafeArea(
            child: Column(
              children: [
                // Top Bar
                Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 20, vertical: 10),
                    child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          GlassIconButton(
                              icon: Icons.close_rounded,
                              onTap: () => Navigator.pop(context)),
                          GlassIconButton(
                              icon: _timerDuration == 0
                                  ? Icons.timer_off_rounded
                                  : _timerDuration == 3
                                  ? Icons.timer_3_rounded
                                  : Icons.timer_10_rounded,
                              onTap: () => setState(() => _timerDuration =
                              (_timerDuration == 0
                                  ? 3
                                  : (_timerDuration == 3 ? 10 : 0)))),
                          GlassIconButton(
                              icon: _isFlashOn
                                  ? Icons.flash_on_rounded
                                  : Icons.flash_off_rounded,
                              color:
                              _isFlashOn ? Colors.yellow : Colors.white,
                              onTap: () {
                                setState(() => _isFlashOn = !_isFlashOn);
                                if (_controller != null &&
                                    _controller!.value.isInitialized) {
                                  _controller!.setFlashMode(_isFlashOn
                                      ? FlashMode.always
                                      : FlashMode.off);
                                }
                              }),
                        ])),
                const Spacer(),
                // Bottom Bar
                Padding(
                    padding: const EdgeInsets.only(bottom: 30),
                    child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                        children: [
                          GlassIconButton(
                              icon: _isGridEnabled
                                  ? Icons.grid_4x4_rounded
                                  : Icons.grid_off_rounded,
                              onTap: _toggleGrid),
                          GestureDetector(
                              onTap: _attemptTakePhoto,
                              child: ShutterButton(
                                  isRecording: _isTakingPicture)),
                          GlassIconButton(
                              icon: Icons.flip_camera_ios_rounded,
                              size: 50,
                              onTap: _switchCamera),
                        ])),
              ],
            ),
          ),
        ],
      ),
    );
  }

  // --- Helpers ---

  List<double> _computeFixedZoomPresets(double min, double max) =>
      [min, 2.0, 5.0].where((z) => z >= min && z <= max).toList();

  Widget _buildZoomPresetRow() {
    return Row(
        mainAxisSize: MainAxisSize.min,
        children: _zoomPresets.map((z) {
          final active = (z - _currentZoomLevel).abs() < 0.1;
          return Padding(
              padding: const EdgeInsets.all(4.0),
              child: GestureDetector(
                  onTap: () => _animateZoomTo(z),
                  child: CircleAvatar(
                      backgroundColor:
                      active ? Colors.white : Colors.black54,
                      radius: 18,
                      child: Text("${z.toInt()}x",
                          style: TextStyle(
                              fontSize: 10,
                              color: active ? Colors.black : Colors.white)))));
        }).toList());
  }

  void _startZoomLabelTimer() {
    _zoomLabelTimer?.cancel();
    _zoomLabelTimer = Timer(const Duration(seconds: 2),
            () => setState(() => _showZoomLabel = false));
  }

  void _startHideUITimers() {
    _exposureTimer?.cancel();
    _exposureTimer = Timer(const Duration(seconds: 4),
            () => setState(() => _showFocusUI = false));
  }

  Future<dynamic> _handleNativeMethodCall(MethodCall call) async {
    if (call.method == 'volume') {
      Logger.debug('Volume button press detected, triggering capture.');
      _attemptTakePhoto();
    }
    return null;
  }

  bool _onKey(KeyEvent event) {
    if (event is KeyDownEvent &&
        (event.logicalKey == LogicalKeyboardKey.audioVolumeUp ||
            event.logicalKey == LogicalKeyboardKey.audioVolumeDown)) {
      _attemptTakePhoto();
      return true;
    }
    return false;
  }
}

lib/src/features/journal/presentation/widgets/camera/image_processor.dart:
import 'dart:io';

import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:image/image.dart' as img;

import '../../../../../core/utils/logger_service.dart';

/// Processes an image in a background isolate to avoid blocking the UI thread.
///
/// This function handles:
/// 1. **Analysis**: Checks image dimensions without full decoding.
/// 2. **Optimization Strategy**: Chooses between a fast native path or a slower,
///    feature-rich Dart path based on requirements (cropping/mirroring).
/// 3. **Transformation**: Performs mirroring (for front camera), cropping (to 3:4),
///    and resizing (memory optimization).
/// 4. **Compression**: Re-encodes the result to JPEG.
///
/// Returns the path to the processed image, or the original path if processing fails.
Future<String?> processAndSaveImage(dynamic rawArgs) async {
  try {
    // Parse arguments passed from the main isolate.
    final Map args = rawArgs as Map;
    final String path = args['path'] as String;
    final bool isFront = args['isFront'] as bool;
    final bool mirror = args['mirror'] as bool? ?? false;
    final double targetAspect = args['aspect'] as double? ?? (3 / 4);

    final file = File(path);
    if (!await file.exists()) {
      Logger.warning('Image processing skipped: Source file not found at $path');
      return null;
    }

    final bytes = await file.readAsBytes();

    // 1. Lightweight Header Analysis (Compatible with image v4.5.4+)
    // We find the decoder and read metadata without decoding the full pixel buffer.
    final decoder = img.findDecoderForData(bytes);
    if (decoder == null) {
      Logger.warning('Image processing skipped: Unsupported image format.');
      return path;
    }

    final info = decoder.startDecode(bytes);
    if (info == null) {
      Logger.warning('Image processing skipped: Could not decode image headers.');
      return path;
    }

    final int width = info.width;
    final int height = info.height;

    // Calculate current aspect ratio to determine if cropping is necessary.
    double currentAspect = width < height ? width / height : height / width;

    // Allow a small tolerance (0.05) for pixel rounding differences.
    bool needsCrop = (currentAspect - targetAspect).abs() > 0.05;

    // --- FAST PATH (Native Compression) ---
    // Used when no geometric transformations (Crop/Mirror) are needed.
    // This is significantly faster and uses less memory.
    if (!needsCrop && !mirror) {
      Logger.debug('Using fast native path for image compression.');
      final result = await FlutterImageCompress.compressAndGetFile(
        path,
        path,
        quality: 85,
        autoCorrectionAngle: true, // Respects EXIF orientation
      );
      return result?.path ?? path;
    }

    // --- SLOW PATH (Dart Image Package) ---
    // Required for pixel-level manipulations like Cropping or Mirroring.

    Logger.debug(
        'Using advanced processing path (Crop: $needsCrop, Mirror: $mirror).');

    // Full decoding of image pixels.
    img.Image? image = img.decodeImage(bytes);
    if (image == null) return path;

    // 1. Fix Orientation: Bakes EXIF orientation into the pixels.
    image = img.bakeOrientation(image);

    // 2. Mirroring: Flips the image horizontally (common for selfies).
    if (isFront && mirror) {
      image = img.flipHorizontal(image);
    }

    // 3. Cropping: Adjusts the image to the target aspect ratio (e.g., 3:4).
    if (needsCrop) {
      int imgW = image.width;
      int imgH = image.height;
      int cropWidth, cropHeight;

      if (imgW / imgH > targetAspect) {
        cropHeight = imgH;
        cropWidth = (imgH * targetAspect).toInt();
      } else {
        cropWidth = imgW;
        cropHeight = (imgW / targetAspect).toInt();
      }

      final int x = (imgW - cropWidth) ~/ 2;
      final int y = (imgH - cropHeight) ~/ 2;

      image = img.copyCrop(
        image,
        x: x,
        y: y,
        width: cropWidth,
        height: cropHeight,
      );
    }

    // 4. Resize: Downscales huge images to save storage and memory.
    if (image.width > 2500) {
      image = img.copyResize(image, width: 2500);
    }

    // 5. Encode: Saves the modified image buffer back to JPEG.
    final jpg = img.encodeJpg(image, quality: 85);

    // Explicitly nullify the image object to help GC in the isolate.
    image = null;

    await file.writeAsBytes(jpg, flush: true);
    Logger.debug('Image processing completed successfully.');

    return path;
  } catch (e, st) {
    // In a background isolate, we log the error and return the original path
    // to ensure the user doesn't lose their photo, even if optimization fails.
    Logger.error("ImageProcessor failed", e, st);
    return (rawArgs is Map && rawArgs['path'] is String)
        ? rawArgs['path']
        : null;
  }
}

lib/src/features/journal/presentation/widgets/settings/language_selector_sheet.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';

import '../../../../../core/providers/locale_provider.dart';
import '../../../../../core/providers/theme_provider.dart';
import '../../../../../core/utils/logger_service.dart';
import '../../../../../../l10n/app_localizations.dart';

/// A professional bottom sheet widget that allows the user to select the application language.
///
/// This widget is designed to be displayed within a modal bottom sheet. It lists
/// the supported languages and updates the global [localeProvider] upon selection.
/// It follows the same design pattern as the theme selector for a cohesive user experience.
class LanguageSelector extends ConsumerWidget {
  /// Creates a [LanguageSelector] instance.
  const LanguageSelector({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final currentLocale = ref.watch(localeProvider);
    final theme = Theme.of(context);
    final accentColor = ref.watch(accentColorProvider);

    // Definition of supported languages.
    // In a global scale app, this list could come from a config file or remote config.
    final List<_LanguageModel> languages = [
      _LanguageModel(name: "English", flag: "🇺🇸", locale: const Locale('en')),
      _LanguageModel(name: "Română", flag: "🇷🇴", locale: const Locale('ro')),
      _LanguageModel(name: "Français", flag: "🇫🇷", locale: const Locale('fr')),
    ];

    return Container(
      padding: const EdgeInsets.fromLTRB(24, 12, 24, 32),
      decoration: BoxDecoration(
        color: theme.scaffoldBackgroundColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Sheet Handle
          Container(
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: theme.dividerColor.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const Gap(24),
          Text(
            l10n.chooseLanguage,
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.w900,
            ),
          ),
          const Gap(24),

          // List of languages wrapped in a flexible container to handle layout constraints.
          Flexible(
            child: ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: languages.length,
              separatorBuilder: (context, index) => const Gap(8),
              itemBuilder: (context, index) {
                final lang = languages[index];
                final isSelected =
                    currentLocale.languageCode == lang.locale.languageCode;

                return _LanguageTile(
                  lang: lang,
                  isSelected: isSelected,
                  accentColor: accentColor,
                  onTap: () {
                    Logger.info(
                        'User selected language: ${lang.name} (${lang.locale.languageCode})');
                    HapticFeedback.lightImpact();
                    ref.read(localeProvider.notifier).setLocale(lang.locale);
                    Navigator.pop(context);
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

/// A specialized visual component for displaying a single language option.
///
/// Renders the flag, language name, and a selection indicator if active.
class _LanguageTile extends StatelessWidget {
  /// The data model containing language details.
  final _LanguageModel lang;

  /// Whether this language is currently active.
  final bool isSelected;

  /// The application's current accent color, used for highlighting.
  final Color accentColor;

  /// Callback triggered when the user taps this tile.
  final VoidCallback onTap;

  const _LanguageTile({
    required this.lang,
    required this.isSelected,
    required this.accentColor,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16),
          color: isSelected
              ? accentColor.withValues(alpha: 0.1)
              : Colors.transparent,
          border: Border.all(
            color: isSelected
                ? accentColor.withValues(alpha: 0.3)
                : Colors.transparent,
            width: 1.5,
          ),
        ),
        child: Row(
          children: [
            Text(
              lang.flag,
              style: const TextStyle(fontSize: 28),
            ),
            const Gap(16),
            Expanded(
              child: Text(
                lang.name,
                style: theme.textTheme.bodyLarge?.copyWith(
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.textTheme.bodyLarge?.color,
                ),
              ),
            ),
            if (isSelected)
              Icon(
                Icons.check_circle_rounded,
                color: accentColor,
                size: 24,
              ),
          ],
        ),
      ),
    );
  }
}

/// A private data model representing a supported language.
class _LanguageModel {
  final String name;
  final String flag;
  final Locale locale;

  _LanguageModel({
    required this.name,
    required this.flag,
    required this.locale,
  });
}

lib/src/features/journal/presentation/widgets/settings/settings_section.dart:
import 'package:flutter/material.dart';
import 'package:gap/gap.dart';

/// A reusable container widget for grouping settings items with a consistent visual style.
///
/// This widget renders a titled section containing a list of [children] widgets,
/// wrapped in a card-like container. It handles theme-specific styling (Light vs Dark)
/// to ensure contrast and visual hierarchy.
class SettingsSection extends StatelessWidget {
  /// The section header text, displayed in uppercase.
  final String title;

  /// The list of widgets (usually settings tiles) to display within the section.
  final List<Widget> children;

  /// Optional text displayed below the section, useful for explanatory notes.
  final String? footer;

  /// Creates a [SettingsSection].
  const SettingsSection({
    super.key,
    required this.title,
    required this.children,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isDark = theme.brightness == Brightness.dark;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Section Title
        Padding(
          padding: const EdgeInsets.only(left: 20, bottom: 10, top: 16),
          child: Text(
            title.toUpperCase(),
            style: theme.textTheme.labelMedium?.copyWith(
              fontWeight: FontWeight.bold,
              letterSpacing: 1.5,
              color: colorScheme.primary.withValues(alpha: 0.7),
            ),
          ),
        ),

        // Main Container (Card)
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 0),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(24),
            // Maintains a constant physical size across themes.
            // In Dark Mode, the border is transparent rather than removed to prevent layout shifts.
            border: Border.all(
              color: isDark
                  ? Colors.transparent
                  : colorScheme.outline.withValues(alpha: 0.15),
              width: 1,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: isDark ? 0.2 : 0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              )
            ],
          ),
          child: Material(
            // Adapts background color for depth perception:
            // Light Mode: Uses a slightly transparent 'surfaceContainerHighest' for a subtle grey.
            // Dark Mode: Uses 'surfaceContainerLow' for standard dark elevation.
            color: isDark
                ? colorScheme.surfaceContainerLow
                : colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
            borderRadius: BorderRadius.circular(24),
            clipBehavior: Clip.antiAlias,
            child: Column(
              children: _buildChildrenWithSeparators(theme),
            ),
          ),
        ),

        // Optional Footer
        if (footer != null)
          Padding(
            padding: const EdgeInsets.only(left: 20, right: 20, top: 10),
            child: Text(
              footer!,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.hintColor,
              ),
            ),
          ),
        const Gap(8),
      ],
    );
  }

  /// Helper method to insert dividers between children.
  List<Widget> _buildChildrenWithSeparators(ThemeData theme) {
    if (children.isEmpty) return [];
    final List<Widget> items = [];
    final isDark = theme.brightness == Brightness.dark;

    for (int i = 0; i < children.length; i++) {
      items.add(children[i]);
      // Add a divider after every item except the last one.
      if (i < children.length - 1) {
        items.add(
          Divider(
            height: 1,
            indent: 56,
            endIndent: 16,
            color: theme.dividerColor.withValues(alpha: isDark ? 0.08 : 0.15),
          ),
        );
      }
    }
    return items;
  }
}

lib/src/features/journal/presentation/widgets/settings/theme_selector_sheet.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';

import '../../../../../core/providers/theme_provider.dart';
import '../../../../../core/utils/logger_service.dart';
import '../../../../../../l10n/app_localizations.dart';

/// A bottom sheet widget that allows users to select the application's accent color.
///
/// This widget displays all available color themes in a unified, responsive grid.
/// It handles user selection, displays premium status badges, and provides
/// haptic feedback upon interaction.
class ThemeSelector extends ConsumerWidget {
  /// Creates a [ThemeSelector] instance.
  const ThemeSelector({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final currentAccent = ref.watch(accentColorProvider);
    final theme = Theme.of(context);

    // Defines the complete list of available themes.
    // The order in this list determines the display order in the grid.
    final List<_ThemeModel> allThemes = [
      // --- Basic Themes ---
      _ThemeModel(name: l10n.themeKrono, color: const Color(0xFF6366F1)),
      _ThemeModel(name: l10n.themeEmerald, color: Colors.teal),
      _ThemeModel(name: l10n.themeOcean, color: Colors.blue),
      _ThemeModel(name: l10n.themeSunset, color: Colors.orange),

      // --- Premium Themes ---
      // These will automatically wrap to the next line in the grid.
      _ThemeModel(
          name: l10n.themeBerry, color: Colors.pink, isPremium: true),
      _ThemeModel(
          name: l10n.themeMidnight, color: Colors.deepPurple, isPremium: true),
      _ThemeModel(
          name: l10n.themeGarnet,
          color: const Color(0xFF7F1D1D),
          isPremium: true),
      _ThemeModel(
          name: l10n.themeAurora,
          color: const Color(0xFF22D3EE),
          isPremium: true),
    ];

    return Container(
      padding: const EdgeInsets.fromLTRB(24, 12, 24, 48),
      decoration: BoxDecoration(
        color: theme.scaffoldBackgroundColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Visual drag handle indicator
          Container(
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: theme.dividerColor.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const Gap(24),

          // Sheet Title
          Text(
            l10n.chooseTheme,
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.w900,
            ),
          ),
          const Gap(32),

          // Renders the grid of theme options.
          // The Wrap widget automatically handles line breaking based on available width.
          _ThemeGrid(
            themes: allThemes,
            currentAccent: currentAccent,
            onSelected: (color) => _handleSelection(context, ref, color),
          ),
        ],
      ),
    );
  }

  /// Updates the application theme and closes the sheet.
  void _handleSelection(BuildContext context, WidgetRef ref, Color color) {
    Logger.info('User selected new accent color: ${color.toARGB32()}');
    HapticFeedback.lightImpact();
    ref.read(accentColorProvider.notifier).setAccentColor(color);
    Navigator.pop(context);
  }
}

/// A helper widget responsible for rendering the responsive grid of theme options.
class _ThemeGrid extends StatelessWidget {
  /// The list of themes to display.
  final List<_ThemeModel> themes;

  /// The currently active accent color.
  final Color currentAccent;

  /// Callback triggered when a theme is selected.
  final ValueChanged<Color> onSelected;

  const _ThemeGrid({
    required this.themes,
    required this.currentAccent,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 16, // Horizontal spacing between items
      runSpacing: 24, // Vertical spacing between lines
      alignment: WrapAlignment.center,
      children: themes.map((t) {
        // Compare integer values of colors to determine selection state.
        // Using toARGB32() instead of deprecated .value
        final isSelected = currentAccent.toARGB32() == t.color.toARGB32();

        return _ThemeChip(
          model: t,
          isSelected: isSelected,
          onTap: () => onSelected(t.color),
        );
      }).toList(),
    );
  }
}

/// A widget representing a single theme option (Circle + Label).
class _ThemeChip extends StatelessWidget {
  /// The data model for the theme.
  final _ThemeModel model;

  /// Whether this chip is currently selected.
  final bool isSelected;

  /// Callback triggered on tap.
  final VoidCallback onTap;

  const _ThemeChip({
    required this.model,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return GestureDetector(
      onTap: onTap,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        // Aligns circles to the top to ensure uniformity even if text wraps.
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          // The Color Circle Indicator
          AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            padding: const EdgeInsets.all(4),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(
                color: isSelected ? model.color : Colors.transparent,
                width: 2,
              ),
            ),
            child: Stack(
              alignment: Alignment.center,
              children: [
                CircleAvatar(
                  radius: 28,
                  backgroundColor: model.color,
                  child: isSelected
                      ? const Icon(Icons.check, color: Colors.white, size: 28)
                      : null,
                ),
                // Premium Badge Indicator
                if (model.isPremium)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.surface,
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withValues(alpha: 0.1),
                            blurRadius: 4,
                          )
                        ],
                      ),
                      child: const Icon(Icons.star_rounded,
                          size: 12, color: Colors.orange),
                    ),
                  ),
              ],
            ),
          ),
          const Gap(8),

          // The Theme Label
          SizedBox(
            width: 76, // Fixed width to ensure consistent grid alignment
            child: Text(
              model.name,
              textAlign: TextAlign.center,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
              softWrap: true,
              style: theme.textTheme.labelMedium?.copyWith(
                height: 1.1,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: isSelected ? theme.colorScheme.primary : theme.hintColor,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// A private data model representing a theme option.
class _ThemeModel {
  final String name;
  final Color color;
  final bool isPremium;

  _ThemeModel({
    required this.name,
    required this.color,
    this.isPremium = false,
  });
}

lib/src/features/journal/presentation/widgets/settings/time_picker_sheet.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';

import '../../../../../core/providers/notification_provider.dart';
import '../../../../../core/utils/logger_service.dart';
import '../../../../../../l10n/app_localizations.dart';

/// A professional bottom sheet widget for selecting a time.
///
/// Supports two modes:
/// 1. **Wheel Picker:** A classic iOS-style scrolling wheel.
/// 2. **Input Picker:** A direct text input for precise entry.
///
/// This widget is optimized for keyboard interactions, ensuring the layout
/// adjusts smoothly without resizing the decorative container abruptly.
class TimePickerSheet extends ConsumerStatefulWidget {
  /// Creates a [TimePickerSheet].
  const TimePickerSheet({super.key});

  @override
  ConsumerState<TimePickerSheet> createState() => _TimePickerSheetState();
}

class _TimePickerSheetState extends ConsumerState<TimePickerSheet> {
  bool _isWheelMode = true;
  late int _hour;
  late int _minute;

  late TextEditingController _hourController;
  late TextEditingController _minuteController;

  @override
  void initState() {
    super.initState();
    final state = ref.read(notificationProvider);
    _hour = state.hour;
    _minute = state.minute;

    _hourController =
        TextEditingController(text: _hour.toString().padLeft(2, '0'));
    _minuteController =
        TextEditingController(text: _minute.toString().padLeft(2, '0'));
  }

  @override
  void dispose() {
    _hourController.dispose();
    _minuteController.dispose();
    super.dispose();
  }

  /// Validates and persists the selected time.
  Future<void> _handleSave() async {
    HapticFeedback.mediumImpact();

    int finalHour = _hour;
    int finalMinute = _minute;

    // If in input mode, parse the text fields.
    if (!_isWheelMode) {
      finalHour = int.tryParse(_hourController.text) ?? _hour;
      finalMinute = int.tryParse(_minuteController.text) ?? _minute;
      finalHour = finalHour.clamp(0, 23);
      finalMinute = finalMinute.clamp(0, 59);
    }

    Logger.info('User saved new reminder time: $finalHour:$finalMinute');

    await ref.read(notificationProvider.notifier).updateSettings(
      true,
      finalHour,
      finalMinute,
    );

    if (mounted) Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Retrieve the keyboard height to adjust padding dynamically.
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    // OPTIMIZATION: The main container does NOT have bottom padding for the keyboard.
    // It remains fixed, while the internal SingleChildScrollView handles the offset.
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(28)),
      ),
      padding: const EdgeInsets.fromLTRB(24, 12, 24, 0),
      child: SingleChildScrollView(
        // Clamping physics prevents visual bouncing during resize events.
        physics: const ClampingScrollPhysics(),
        child: Padding(
          // OPTIMIZATION: Padding is applied here at the end of the scroll view.
          // This pushes content up when the keyboard opens without resizing the decorative container.
          padding: EdgeInsets.only(bottom: bottomInset + 24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Drag Handle
              Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: theme.dividerColor.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),

              // Header Row
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Gap(48), // Spacer to balance the icon button
                  Text(
                    l10n.dailyReminder,
                    style: theme.textTheme.titleLarge
                        ?.copyWith(fontWeight: FontWeight.bold),
                  ),
                  IconButton(
                    onPressed: () {
                      HapticFeedback.lightImpact();
                      setState(() => _isWheelMode = !_isWheelMode);
                    },
                    icon: Icon(
                      _isWheelMode
                          ? Icons.keyboard_rounded
                          : Icons.access_time_filled_rounded,
                      color: colorScheme.primary,
                    ),
                  ),
                ],
              ),
              const Gap(32),

              // Picker Area (Fixed Height for consistency)
              SizedBox(
                height: 200,
                child: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 300),
                  switchInCurve: Curves.easeOutQuad,
                  switchOutCurve: Curves.easeInQuad,
                  child: _isWheelMode
                      ? _buildWheelPicker(colorScheme)
                      : _buildInputPicker(colorScheme),
                ),
              ),

              const Gap(48),

              // Save Button
              SizedBox(
                width: double.infinity,
                height: 58,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: colorScheme.primary,
                    foregroundColor: colorScheme.onPrimary,
                    elevation: 0,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20)),
                  ),
                  onPressed: _handleSave,
                  child: Text(
                    l10n.save,
                    style: const TextStyle(
                        fontWeight: FontWeight.bold, fontSize: 18),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Renders the scrolling wheel picker.
  Widget _buildWheelPicker(ColorScheme colorScheme) {
    return Stack(
      key: const ValueKey('wheel'),
      alignment: Alignment.center,
      children: [
        // Selection Highlight Bar
        Container(
          height: 64,
          width: 200,
          decoration: BoxDecoration(
            color: colorScheme.primary.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(16),
          ),
        ),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _WheelColumn(
              initialItem: _hour,
              maxItems: 24,
              onChanged: (v) => _hour = v,
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12),
              child: Text(
                ":",
                style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: colorScheme.primary),
              ),
            ),
            _WheelColumn(
              initialItem: _minute,
              maxItems: 60,
              onChanged: (v) => _minute = v,
            ),
          ],
        ),
      ],
    );
  }

  /// Renders the text input picker.
  Widget _buildInputPicker(ColorScheme colorScheme) {
    return Row(
      key: const ValueKey('input'),
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        _TimeInputBox(
            controller: _hourController, label: "HH", colorScheme: colorScheme),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Text(
            ":",
            style: TextStyle(
                fontSize: 40,
                fontWeight: FontWeight.bold,
                color: colorScheme.primary),
          ),
        ),
        _TimeInputBox(
            controller: _minuteController,
            label: "MM",
            colorScheme: colorScheme),
      ],
    );
  }
}

/// A reusable scrolling column for the wheel picker.
class _WheelColumn extends StatelessWidget {
  final int initialItem;
  final int maxItems;
  final ValueChanged<int> onChanged;

  const _WheelColumn({
    required this.initialItem,
    required this.maxItems,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    // Simulate infinite scrolling by starting at a large index offset.
    final int infiniteCenter = 1000 * maxItems;
    final int initialScrollIndex = infiniteCenter + initialItem;

    return SizedBox(
      width: 70,
      height: 200,
      child: ListWheelScrollView.useDelegate(
        controller:
        FixedExtentScrollController(initialItem: initialScrollIndex),
        itemExtent: 60,
        physics: const FixedExtentScrollPhysics(),
        perspective: 0.005,
        useMagnifier: true,
        magnification: 1.1,
        overAndUnderCenterOpacity: 0.5,
        onSelectedItemChanged: (index) {
          final value = index % maxItems;
          onChanged(value);
          HapticFeedback.selectionClick();
        },
        childDelegate: ListWheelChildBuilderDelegate(
          childCount: null, // Infinite
          builder: (context, index) {
            final value = (index % maxItems + maxItems) % maxItems;
            return Center(
              child: Text(
                value.toString().padLeft(2, '0'),
                style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.w600,
                    color: colorScheme.onSurface),
              ),
            );
          },
        ),
      ),
    );
  }
}

/// A styled text input box for manual time entry.
class _TimeInputBox extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final ColorScheme colorScheme;

  const _TimeInputBox({
    required this.controller,
    required this.label,
    required this.colorScheme,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 90,
      height: 90,
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerHigh,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: colorScheme.primary.withValues(alpha: 0.2)),
      ),
      child: Center(
        child: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          textAlign: TextAlign.center,
          maxLength: 2,
          autofocus: false, // Prevents aggressive focus which can cause UI lag.
          inputFormatters: [FilteringTextInputFormatter.digitsOnly],
          style: const TextStyle(fontSize: 44, fontWeight: FontWeight.bold),
          decoration: InputDecoration(
            border: InputBorder.none,
            counterText: "",
            hintText: label,
            hintStyle: TextStyle(color: colorScheme.outlineVariant),
            contentPadding: EdgeInsets.zero,
          ),
          onChanged: (value) {
            // Automatically move focus to the next field when 2 digits are entered.
            if (value.length == 2) FocusScope.of(context).nextFocus();
          },
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/widgets/journal_grid.dart:
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:gap/gap.dart';

import '../../../../../l10n/app_localizations.dart';
import '../../../../core/utils/logger_service.dart';
import '../../data/models/journal_entry.dart';
import 'journal_item_card.dart';

/// A widget that displays a list of [JournalEntry] items in a scrollable grid,
/// visually grouped and sectioned by month.
class JournalGrid extends StatelessWidget {
  /// The complete list of journal entries to be displayed.
  final List<JournalEntry> entries;

  /// Creates a grid for displaying journal entries.
  const JournalGrid({super.key, required this.entries});

  /// Generates a list of slivers for a [CustomScrollView] to display journal entries.
  ///
  /// This method groups the provided [entries] by month, creating a header for each
  /// month followed by a grid of [JournalItemCard] widgets for each day.
  /// It includes performance optimizations such as pre-calculating image cache sizes
  /// and disabling `addAutomaticKeepAlives` for smoother scrolling with large datasets.
  static List<Widget> sliversFor(List<JournalEntry> entries, BuildContext context) {
    Logger.info('Generating journal grid slivers for ${entries.length} entries.');
    final width = MediaQuery.of(context).size.width;
    final dpr = MediaQuery.of(context).devicePixelRatio;
    // Calculate the exact width of a column in physical pixels for image caching.
    final int itemCacheSize = ((width - 40 - 16) / 3 * dpr).round();

    final sections = _groupOptimized(entries);
    final now = DateTime.now();

    final children = <Widget>[];

    for (final section in sections) {
      final bool isCurrentMonth = section.year == now.year && section.month == now.month;
      final int daysToShow = isCurrentMonth ? now.day : section.daysInMonth;

      final String monthName = DateFormat('MMMM yyyy', Localizations.localeOf(context).languageCode)
          .format(DateTime(section.year, section.month));

      children.add(SliverToBoxAdapter(
          child: _MonthHeader(
              title: monthName,
              count: section.total,
              memoriesLabel: AppLocalizations.of(context)!.memoriesCount(section.total)
          )
      ));

      children.add(
        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 20),
          sliver: SliverGrid(
            delegate: SliverChildBuilderDelegate(
                  (context, index) {
                final day = daysToShow - index;
                final date = DateTime(section.year, section.month, day);
                final dayEntries = section.days[day] ?? [];

                return JournalItemCard(
                    date: date,
                    dayEntries: dayEntries,
                    cacheSize: itemCacheSize
                );
              },
              childCount: daysToShow,
              addAutomaticKeepAlives: false,
              addRepaintBoundaries: false,
            ),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
              childAspectRatio: 0.85,
            ),
          ),
        ),
      );

      children.add(const SliverToBoxAdapter(child: Gap(24)));
    }

    children.add(const SliverToBoxAdapter(child: Gap(80)));
    return children;
  }

  /// Groups a list of [JournalEntry] items by month using an efficient integer-based key.
  ///
  /// The key is generated as `year * 100 + month` (e.g., May 2024 becomes 202405),
  /// which is faster for sorting and map lookups than string-based keys.
  /// Returns a list of [_MonthData] sorted in descending chronological order.
  static List<_MonthData> _groupOptimized(List<JournalEntry> entries) {
    final map = <int, _MonthData>{};
    for (final e in entries) {
      final key = e.date.year * 100 + e.date.month;

      final monthData = map.putIfAbsent(key, () => _MonthData(year: e.date.year, month: e.date.month));
      monthData.add(e);
    }
    final sortedKeys = map.keys.toList()..sort((a, b) => b.compareTo(a));
    return sortedKeys.map((k) => map[k]!).toList();
  }

  @override
  Widget build(BuildContext context) => CustomScrollView(slivers: sliversFor(entries, context));
}

/// A private helper class to store and manage journal entries for a single month.
class _MonthData {
  /// The year of the month (e.g., 2024).
  final int year;
  /// The month number (1-12).
  final int month;
  /// A map where keys are days of the month and values are lists of entries for that day.
  final Map<int, List<JournalEntry>> days = {};

  /// Constructs data for a specific month.
  _MonthData({required this.year, required this.month});

  /// Adds a [JournalEntry] to the correct day within this month's data.
  void add(JournalEntry e) {
    days.putIfAbsent(e.date.day, () => []).add(e);
  }

  /// The total number of days in this specific month and year.
  int get daysInMonth => DateUtils.getDaysInMonth(year, month);
  /// The total count of all journal entries within this month.
  int get total => days.values.fold(0, (s, l) => s + l.length);
}

/// A private widget that displays a title and a subtitle for a month section.
///
/// Used as a header in the journal grid to separate entries from different months.
class _MonthHeader extends StatelessWidget {
  /// The main title, typically the month and year (e.g., "May 2024").
  final String title;
  /// The total number of entries for this month.
  final int count;
  /// The localized label describing the number of memories (e.g., "5 memories").
  final String memoriesLabel;

  /// Creates a header for a month section.
  const _MonthHeader({required this.title, required this.count, required this.memoriesLabel});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final formattedTitle = title.isNotEmpty ? title[0].toUpperCase() + title.substring(1) : title;

    return Padding(
      padding: const EdgeInsets.only(left: 24, right: 24, top: 32, bottom: 16),
      child: Row(children: [
        Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Text(formattedTitle, style: theme.textTheme.labelLarge?.copyWith(fontWeight: FontWeight.w900, fontSize: 18)),
          const Gap(4),
          Text(memoriesLabel, style: theme.textTheme.labelSmall?.copyWith(color: theme.colorScheme.primary.withAlpha(179), fontWeight: FontWeight.w600)),
        ]),
        const Gap(16),
        const Expanded(child: Divider(thickness: 1)),
      ]),
    );
  }
}

lib/src/features/journal/presentation/widgets/journal_item_card.dart:
import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:gap/gap.dart';
import 'package:intl/intl.dart';

import '../../../../../l10n/app_localizations.dart';
import '../../../../core/utils/logger_service.dart';
import '../../data/models/journal_entry.dart';
import '../add_entry_screen.dart';
import '../entry_detail_screen.dart';

/// A cache of emoji strings corresponding to mood ratings 1 through 5.
const _emojiCache = ['😢', '🙁', '😐', '🙂', '🤩'];

/// A card representing a single day in the journal grid.
///
/// Displays a thumbnail from a [JournalEntry] if one exists for the given [date].
/// Handles user interactions such as tapping to view details or add a new entry,
/// and long-pressing to show a preview overlay. It can also display a badge
/// indicating multiple entries for a single day.
class JournalItemCard extends StatefulWidget {
  /// The specific date this card represents.
  final DateTime date;

  /// A list of all journal entries recorded for this [date].
  final List<JournalEntry> dayEntries;

  /// The target width in physical pixels for image caching, optimizing memory usage.
  final int cacheSize;

  /// Creates a card widget for a day in the journal.
  const JournalItemCard({
    super.key,
    required this.date,
    required this.dayEntries,
    required this.cacheSize,
  });

  @override
  State<JournalItemCard> createState() => _JournalItemCardState();
}

/// Manages the state for [JournalItemCard], including animations and overlay visibility.
class _JournalItemCardState extends State<JournalItemCard> {
  /// The overlay entry used to display the long-press image preview.
  OverlayEntry? _overlayEntry;

  /// Tracks the pressed state for tap-down animations.
  bool _isPressed = false;

  /// Gets the emoji for the most significant entry of the day.
  ///
  /// If multiple entries exist, it selects the one with the highest mood rating.
  /// Returns an empty string if there are no entries for the day.
  String get _currentEmoji {
    if (widget.dayEntries.isEmpty) return '';
    final mainEntry = widget.dayEntries.reduce((a, b) => a.moodRating >= b.moodRating ? a : b);
    return _getEmoji(mainEntry.moodRating);
  }

  @override
  void dispose() {
    _hideOverlay();
    super.dispose();
  }

  /// Determines if the card's [date] is the current calendar day.
  bool get _isToday {
    final now = DateTime.now();
    return widget.date.year == now.year &&
        widget.date.month == now.month &&
        widget.date.day == now.day;
  }

  /// Converts a mood rating (1-5) into its corresponding emoji representation.
  String _getEmoji(int rating) {
    final idx = rating.clamp(1, 5) - 1;
    return _emojiCache[idx];
  }

  /// Handles the tap gesture on the card, routing to the appropriate action.
  ///
  /// If the day has no entries, it navigates to the add entry screen.
  /// If it has one entry, it navigates to the detail screen.
  /// If it has multiple entries, it shows a modal to let the user choose.
  void _handleTap() {
    if (widget.dayEntries.isEmpty) {
      Logger.info('Tapped on empty day card: ${widget.date}');
      _handleEmptyDayTap();
      return;
    }
    if (widget.dayEntries.length > 1) {
      Logger.info('Tapped card with multiple entries (${widget.dayEntries.length}), showing modal.');
      _showMultipleEntriesModal();
    } else {
      final main = widget.dayEntries.first;
      Logger.info('Tapped card with single entry, navigating to detail screen for entry ID: ${main.id}');
      Navigator.push(
        context,
        MaterialPageRoute(builder: (_) => EntryDetailScreen(entry: main)),
      );
    }
  }

  /// Handles navigation when an empty day card is tapped.
  ///
  /// Navigates to the [AddEntryScreen]. It prevents adding entries for future dates
  /// by showing a [SnackBar].
  void _handleEmptyDayTap() {
    final now = DateTime.now();
    final todayMidnight = DateTime(now.year, now.month, now.day);
    final l10n = AppLocalizations.of(context)!;

    if (widget.date.isAfter(todayMidnight)) {
      Logger.info('Attempted to add entry for a future date: ${widget.date}');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.futureDateError), behavior: SnackBarBehavior.floating),
      );
      return;
    }
    Logger.info('Navigating to add entry screen for date: ${widget.date}');
    Navigator.of(context).push(
      MaterialPageRoute(builder: (_) => AddEntryScreen(initialDate: widget.date)),
    );
  }

  /// Displays a modal bottom sheet with a grid of all entries for the selected day.
  ///
  /// This is triggered when a user taps a card that represents a day with more
  /// than one [JournalEntry].
  void _showMultipleEntriesModal() {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).languageCode;
    final sortedEntries = List<JournalEntry>.from(widget.dayEntries)
      ..sort((a, b) => b.moodRating.compareTo(a.moodRating));
    final String rawDate = DateFormat('d MMMM', locale).format(widget.date);

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      barrierColor: Colors.black.withAlpha(140),
      builder: (context) => Container(
        height: MediaQuery.of(context).size.height * 0.72,
        decoration: BoxDecoration(
          color: Theme.of(context).scaffoldBackgroundColor,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(28)),
        ),
        padding: const EdgeInsets.fromLTRB(20, 12, 20, 20),
        child: Column(
          children: [
            Container(width: 40, height: 4, decoration: BoxDecoration(color: Theme.of(context).colorScheme.onSurface.withAlpha(51), borderRadius: BorderRadius.circular(2))),
            const Gap(20),
            Text(l10n.memoriesFrom(rawDate), style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w800, letterSpacing: -0.5)),
            const Gap(20),
            Expanded(
              child: GridView.builder(
                physics: const BouncingScrollPhysics(),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2, crossAxisSpacing: 16, mainAxisSpacing: 16, childAspectRatio: 0.8,
                ),
                itemCount: sortedEntries.length,
                itemBuilder: (context, index) {
                  final entry = sortedEntries[index];
                  return GestureDetector(
                    onTap: () {
                      Logger.info('Selected entry ID ${entry.id} from multi-entry modal.');
                      Navigator.pop(context);
                      Navigator.push(context, MaterialPageRoute(builder: (_) => EntryDetailScreen(entry: entry)));
                    },
                    child: _buildModalCard(entry),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (widget.dayEntries.isEmpty) {
      return GestureDetector(onTap: _handleTap, child: _buildEmptyDay());
    }

    final mainEntry = widget.dayEntries.reduce((a, b) => a.moodRating >= b.moodRating ? a : b);

    return RepaintBoundary(
      child: AnimatedScale(
        scale: _isPressed ? 0.95 : 1.0,
        duration: const Duration(milliseconds: 100),
        curve: Curves.easeInOut,
        child: GestureDetector(
          onTap: _handleTap,
          onTapDown: (_) => setState(() => _isPressed = true),
          onTapUp: (_) => setState(() => _isPressed = false),
          onTapCancel: () => setState(() => _isPressed = false),
          onLongPressStart: (_) {
            setState(() => _isPressed = true);
            _showOverlay(context, mainEntry);
          },
          onLongPressEnd: (_) {
            setState(() => _isPressed = false);
            _hideOverlay();
          },
          onLongPressCancel: () {
            setState(() => _isPressed = false);
            _hideOverlay();
          },
          child: _buildFilledCard(mainEntry, showDate: true, showBadge: true),
        ),
      ),
    );
  }

  /// Builds the visual representation for a day with no journal entries.
  Widget _buildEmptyDay() {
    final theme = Theme.of(context);
    return Container(
      decoration: BoxDecoration(
        color: _isToday ? theme.colorScheme.primary.withAlpha(20) : theme.colorScheme.surfaceContainerHighest.withAlpha(77),
        borderRadius: BorderRadius.circular(12),
        border: _isToday ? Border.all(color: theme.colorScheme.primary.withAlpha(153), width: 1.4) : null,
      ),
      child: Center(
        child: Text("${widget.date.day}", style: TextStyle(color: _isToday ? theme.colorScheme.primary : theme.colorScheme.onSurfaceVariant.withAlpha(115), fontWeight: _isToday ? FontWeight.w800 : FontWeight.w600, fontSize: 16)),
      ),
    );
  }

  /// Builds the visual representation for a day that has at least one journal entry.
  Widget _buildFilledCard(JournalEntry entry, {bool showDate = true, bool showBadge = false}) {
    final String imagePath = (entry.thumbnailPath?.isNotEmpty == true)
        ? entry.thumbnailPath!
        : (entry.photoPath);

    if (imagePath.isEmpty) {
      Logger.warning('Journal entry ID ${entry.id} has an empty photoPath and thumbnailPath.');
      return _buildBrokenImagePlaceholder();
    }

    final imageFile = File(imagePath);
    if (!imageFile.existsSync()) {
      Logger.warning('Image file does not exist at path: $imagePath for entry ID ${entry.id}.');
      return _buildBrokenImagePlaceholder();
    }

    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        color: Colors.black12,
      ),
      clipBehavior: Clip.antiAlias,
      child: Stack(fit: StackFit.expand, children: [
        Image.file(
          imageFile,
          fit: BoxFit.cover,
          cacheWidth: widget.cacheSize,
          gaplessPlayback: true,
          isAntiAlias: true,
          filterQuality: FilterQuality.medium,
          errorBuilder: (context, error, stackTrace) {
            Logger.error(
              'Failed to decode image file for entry ID ${entry.id} at path: $imagePath',
              error,
              stackTrace!,
            );
            return _buildBrokenImagePlaceholder();
          },
          frameBuilder: (context, child, frame, wasSync) {
            if (wasSync) return child;
            return AnimatedOpacity(
                opacity: frame == null ? 0 : 1,
                duration: const Duration(milliseconds: 220),
                curve: Curves.easeOut,
                child: child
            );
          },
        ),
        if (showDate) ...[
          Positioned(bottom: 0, left: 0, right: 0, height: 56, child: DecoratedBox(decoration: BoxDecoration(gradient: LinearGradient(begin: Alignment.bottomCenter, end: Alignment.topCenter, colors: [Colors.black.withAlpha(166), Colors.transparent], stops: const [0, 0.9])))),
          Positioned(bottom: 6, right: 8, child: Text("${widget.date.day}", style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 13, shadows: [Shadow(color: Colors.black, blurRadius: 3)]))),
        ],
        Positioned(top: 6, left: 6, child: Container(padding: const EdgeInsets.all(4), decoration: BoxDecoration(color: Colors.black.withAlpha(115), shape: BoxShape.circle), child: Text(_currentEmoji, style: const TextStyle(fontSize: 12)))),
        if (showBadge && widget.dayEntries.length > 1)
          Positioned(
            top: 6,
            right: 6,
            child: _buildBadge("${widget.dayEntries.length}"),
          ),
        Positioned.fill(child: Container(decoration: BoxDecoration(borderRadius: BorderRadius.circular(12), border: Border.all(color: Colors.black.withAlpha(20), width: 1, strokeAlign: BorderSide.strokeAlignInside))))
      ]),
    );
  }

  /// Builds a placeholder widget for when an image fails to load or is missing.
  Widget _buildBrokenImagePlaceholder() {
    return Container(
      decoration: BoxDecoration(color: Theme.of(context).colorScheme.surfaceContainerHighest, borderRadius: BorderRadius.circular(12)),
      child: Center(
        child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
          Icon(Icons.broken_image_outlined, color: Theme.of(context).colorScheme.onSurfaceVariant, size: 32),
          const Gap(8),
          Text('Error', style: TextStyle(fontSize: 12, color: Theme.of(context).colorScheme.onSurfaceVariant)),
        ]),
      ),
    );
  }

  /// A convenience method to build a card for the multi-entry modal.
  Widget _buildModalCard(JournalEntry entry) => _buildFilledCard(entry, showDate: false, showBadge: false);

  /// Builds a small badge widget, typically used to show the count of multiple entries.
  Widget _buildBadge(String text) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: Colors.black.withAlpha(158),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.white.withAlpha(41), width: 0.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.copy_rounded, color: Colors.white, size: 10),
          const Gap(4),
          Text(text, style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  /// Safely removes the long-press preview overlay from the screen.
  void _hideOverlay() {
    if (_overlayEntry != null) {
      try {
        _overlayEntry?.remove();
      } catch (e, stack) {
        Logger.error('Failed to remove overlay entry.', e, stack);
      }
      _overlayEntry = null;
    }
  }

  /// Creates and displays a full-screen overlay to preview an entry's image.
  ///
  /// Triggered on long-press. It provides haptic feedback and inserts an
  /// [_AnimatedPreviewPopup] into the application's overlay.
  void _showOverlay(BuildContext context, JournalEntry entry) {
    _hideOverlay();
    HapticFeedback.mediumImpact();
    Logger.info('Showing long-press preview for entry ID: ${entry.id}');
    final l10n = AppLocalizations.of(context)!;

    _overlayEntry = OverlayEntry(builder: (context) {
      return _AnimatedPreviewPopup(
          entry: entry,
          labelText: l10n.memoryPopup(_getEmoji(entry.moodRating))
      );
    });

    try {
      Overlay.of(context).insert(_overlayEntry!);
    } catch (e, stack) {
      Logger.error('Failed to insert overlay entry into the overlay.', e, stack);
      _overlayEntry = null;
    }
  }
}

/// A private widget that displays a full-screen, animated preview of a journal entry.
///
/// This popup appears on top of a blurred background when a user long-presses
/// a [JournalItemCard].
class _AnimatedPreviewPopup extends StatefulWidget {
  /// The journal entry to be displayed in the preview.
  final JournalEntry entry;

  /// The label text to display below the image.
  final String labelText;

  /// Creates an animated preview popup.
  const _AnimatedPreviewPopup({required this.entry, required this.labelText});

  @override
  State<_AnimatedPreviewPopup> createState() => _AnimatedPreviewPopupState();
}

class _AnimatedPreviewPopupState extends State<_AnimatedPreviewPopup> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 250),
    );

    _scaleAnimation = CurvedAnimation(parent: _controller, curve: Curves.easeOutBack);
    _fadeAnimation = CurvedAnimation(parent: _controller, curve: Curves.easeOut);

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final cacheSize = (MediaQuery.of(context).size.width * MediaQuery.of(context).devicePixelRatio).round();

    return Material(
      color: Colors.transparent,
      child: Stack(children: [
        FadeTransition(
          opacity: _fadeAnimation,
          child: BackdropFilter(
              filter: ui.ImageFilter.blur(sigmaX: 8, sigmaY: 8),
              child: Container(color: Colors.black.withAlpha(82))
          ),
        ),
        Center(
          child: ScaleTransition(
            scale: _scaleAnimation,
            child: Padding(
              padding: const EdgeInsets.all(28),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                Flexible(
                  child: ClipRRect(
                      borderRadius: BorderRadius.circular(18),
                      child: Image.file(
                        File(widget.entry.photoPath),
                        fit: BoxFit.contain,
                        gaplessPlayback: true,
                        cacheWidth: cacheSize,
                        errorBuilder: (context, error, stackTrace) {
                          Logger.error(
                            'Failed to decode full-size preview image for entry ID ${widget.entry.id}',
                            error,
                            stackTrace!,
                          );
                          return const SizedBox.shrink();
                        },
                      )
                  ),
                ),
                const Gap(14),
                Container(
                    padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),
                    decoration: BoxDecoration(color: Theme.of(context).colorScheme.surface, borderRadius: BorderRadius.circular(18)),
                    child: Text(widget.labelText, style: const TextStyle(fontWeight: FontWeight.bold))
                ),
              ]),
            ),
          ),
        ),
      ]),
    );
  }
}

lib/src/features/journal/presentation/widgets/quote_card.dart:
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/utils/logger_service.dart';
import 'package:gap/gap.dart';

import '../../data/sources/quote_service.dart';

/// A card widget that displays a daily inspirational quote.
///
/// This widget listens to the [quoteProvider] to asynchronously fetch and display
/// a quote. It handles loading and error states gracefully, showing a placeholder
/// during loading and logging any errors to Crashlytics while displaying an empty space.
class QuoteCard extends ConsumerWidget {
  /// Creates a card for displaying a daily quote.
  const QuoteCard({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final quoteAsync = ref.watch(quoteProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return quoteAsync.when(
      data: (quote) {
        Logger.debug('Successfully loaded quote by ${quote.author}');
        return AnimatedSize(
          duration: const Duration(milliseconds: 300),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 20),
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(24),
              border: Border.all(
                color: colorScheme.primary.withValues(alpha: 0.1),
              ),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.format_quote_rounded,
                  size: 28,
                  color: colorScheme.primary.withValues(alpha: 0.7),
                ),
                const Gap(8),
                Text(
                  quote.text,
                  textAlign: TextAlign.center,
                  maxLines: 3,
                  overflow: TextOverflow.ellipsis,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontStyle: FontStyle.italic,
                    fontWeight: FontWeight.w500,
                    height: 1.4,
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
                const Gap(12),
                Text(
                  "- ${quote.author}",
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: colorScheme.primary,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ],
            ),
          ),
        );
      },
      loading: () => const _QuoteLoadingPlaceholder(),
      error: (err, stack) {
        Logger.error('Failed to load daily quote from the service.', err, stack);
        return const SizedBox.shrink();
      },
    );
  }
}

/// A private widget that displays a loading indicator placeholder.
///
/// This is shown within the [QuoteCard] while the quote is being fetched
/// by the [quoteProvider].
class _QuoteLoadingPlaceholder extends StatelessWidget {
  /// Creates the loading placeholder for the quote card.
  const _QuoteLoadingPlaceholder();

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Container(
      height: 120,
      width: double.infinity,
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(24),
      ),
      child: Center(
        child: SizedBox(
          width: 20,
          height: 20,
          child: CircularProgressIndicator(
            strokeWidth: 2,
            color: colorScheme.primary.withValues(alpha: 0.3),
          ),
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/widgets/settings_tile.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../core/utils/logger_service.dart';

/// A reusable and styled list tile for settings screens.
///
/// Provides a consistent layout with an icon, title, optional subtitle,
/// and a trailing widget or navigation chevron. It handles tap feedback
/// and theming automatically.
class SettingsTile extends StatelessWidget {
  /// The icon to display on the left side of the tile.
  final IconData icon;

  /// The primary text label for the setting.
  final String title;

  /// Optional secondary text displayed below the [title].
  final String? subtitle;

  /// An optional widget to display at the end of the tile, replacing the default chevron.
  final Widget? trailing;

  /// The callback function to execute when the tile is tapped. If null, the tile is not interactive.
  final VoidCallback? onTap;

  /// An optional color for the icon and its background highlight. Defaults to the theme's primary color.
  final Color? iconColor;

  /// Creates a settings list tile.
  const SettingsTile({
    super.key,
    required this.icon,
    required this.title,
    this.subtitle,
    this.trailing,
    this.onTap,
    this.iconColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isDark = theme.brightness == Brightness.dark;

    final accentColor = iconColor ?? colorScheme.primary;

    final double iconBgAlpha = isDark ? 0.1 : 0.15;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap != null
            ? () {
          Logger.info('Tapped on settings tile: "$title"');
          HapticFeedback.lightImpact();
          onTap!();
        }
            : null,
        splashColor: accentColor.withValues(alpha: 0.1),
        highlightColor: accentColor.withValues(alpha: 0.05),
        borderRadius: BorderRadius.circular(24),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          child: Row(
            children: [
              // Icon Layout
              Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  color: accentColor.withValues(alpha: iconBgAlpha),
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(
                    color: isDark
                        ? Colors.transparent
                        : accentColor.withValues(alpha: 0.1),
                    width: 0.5,
                  ),
                ),
                child: Icon(
                  icon,
                  color: accentColor,
                  size: 22,
                ),
              ),
              const SizedBox(width: 16),

              // Text Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: theme.textTheme.bodyLarge?.copyWith(
                        fontWeight: FontWeight.w600,
                        letterSpacing: -0.2,
                        color: isDark
                            ? colorScheme.onSurface
                            : colorScheme.onSurface.withValues(alpha: 0.9),
                      ),
                    ),
                    if (subtitle != null) ...[
                      const SizedBox(height: 2),
                      Text(
                        subtitle!,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant
                              .withValues(alpha: isDark ? 0.7 : 0.85),
                        ),
                      ),
                    ],
                  ],
                ),
              ),

              // Trailing logic
              if (trailing != null)
                trailing!
              else if (onTap != null)
                Icon(
                  Icons.chevron_right_rounded,
                  color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/widgets/streak_card.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:gap/gap.dart';
import '../../../../../l10n/app_localizations.dart';
import '../../../../core/utils/logger_service.dart';

/// A gamified widget that displays the user's current consecutive journal days.
///
/// Features a pulsing animation to draw attention and a detailed breakdown
/// of the current week's activity in a bottom sheet when tapped.
class StreakCard extends StatelessWidget {
  /// The current number of consecutive days the user has journaled.
  final int streak;

  /// A list of all dates on which the user has made a journal entry, used for
  /// displaying the weekly activity view.
  final List<DateTime> activeDates;

  /// Creates a card to display the user's journaling streak.
  const StreakCard({
    super.key,
    required this.streak,
    required this.activeDates,
  });

  /// Formats the total days into a human-readable duration (Years, Weeks, Days).
  ///
  /// Takes the [totalDays] and a localized [l10n] instance to produce a string
  /// like "1 year, 2 weeks, 3 days". Returns a prompt to start if the streak is zero.
  String _formatStreakDuration(int totalDays, AppLocalizations l10n) {
    if (totalDays == 0) return l10n.startFirstDay;

    final int years = totalDays ~/ 365;
    final int remainingDays = totalDays % 365;
    final int weeks = remainingDays ~/ 7;
    final int days = remainingDays % 7;

    final List<String> parts = [];
    if (years > 0) parts.add("$years ${years == 1 ? l10n.year : l10n.years}");
    if (weeks > 0) parts.add("$weeks ${l10n.weekShort}");
    if (days > 0 || parts.isEmpty) {
      parts.add("$days ${days == 1 ? l10n.day : l10n.days}");
    }

    final result = parts.join(", ");
    Logger.debug('Formatted streak duration for $totalDays days: "$result"');
    return result;
  }

  @override
  Widget build(BuildContext context) {
    final bool isActive = streak > 0;
    final theme = Theme.of(context);
    final Color streakColor = Colors.orange;
    final Color inactiveColor = theme.disabledColor;

    return GestureDetector(
      onTap: () {
        Logger.info('Streak card tapped. Current streak: $streak');
        HapticFeedback.lightImpact();
        _showStreakDetails(context);
      },
      child: Container(
        margin: const EdgeInsets.only(right: 16, top: 8, bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 6),
        decoration: BoxDecoration(
          color: isActive
              ? streakColor.withValues(alpha: 0.1)
              : inactiveColor.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(24),
          border: Border.all(
            color: isActive
                ? streakColor.withValues(alpha: 0.3)
                : inactiveColor.withValues(alpha: 0.2),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            TweenAnimationBuilder<double>(
              tween: Tween(begin: 0.92, end: 1.08),
              duration: const Duration(seconds: 1),
              curve: Curves.easeInOut,
              builder: (context, scale, child) =>
                  Transform.scale(scale: scale, child: child),
              child: Icon(
                Icons.local_fire_department_rounded,
                color: isActive ? streakColor : inactiveColor,
                size: 20,
              ),
            ),
            const Gap(6),
            Text(
              '$streak',
              style: TextStyle(
                color: isActive ? Colors.orange[900] : theme.hintColor,
                fontWeight: FontWeight.w900,
                fontSize: 14,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Displays a modal bottom sheet with a detailed weekly view of the user's streak.
  ///
  /// This modal shows the formatted streak duration, a grid of the current week's
  /// activity based on the [activeDates], and a motivational message.
  void _showStreakDetails(BuildContext context) {
    Logger.info('Showing streak details modal.');
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final String locale = Localizations.localeOf(context).languageCode;
    final List<String> weekDaysNames =
        DateFormat.E(locale).dateSymbols.NARROWWEEKDAYS;

    final DateTime now = DateTime.now();
    final DateTime today = DateTime(now.year, now.month, now.day);
    final DateTime startOfWeek =
    today.subtract(Duration(days: today.weekday - 1));

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      useSafeArea: true,
      backgroundColor: theme.scaffoldBackgroundColor,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      builder: (context) => Padding(
        padding: const EdgeInsets.fromLTRB(24, 12, 24, 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: theme.dividerColor.withValues(alpha: 0.2),
                borderRadius: BorderRadius.circular(10),
              ),
            ),
            const Gap(32),
            const Icon(Icons.local_fire_department_rounded,
                color: Colors.orange, size: 72),
            const Gap(12),
            Text(
              _formatStreakDuration(streak, l10n),
              textAlign: TextAlign.center,
              style:
              theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.w900),
            ),
            const Gap(4),
            Text(
              l10n.streakSuffix,
              style: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
            ),
            const Gap(32),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: List.generate(7, (index) {
                final DateTime dayDate = startOfWeek.add(Duration(days: index));
                final bool isRecorded = activeDates.any((d) =>
                d.year == dayDate.year &&
                    d.month == dayDate.month &&
                    d.day == dayDate.day);

                final bool isToday = dayDate.year == today.year &&
                    dayDate.month == today.month &&
                    dayDate.day == today.day;

                int dayLabelIndex = (index + 1) % 7;

                return Column(
                  children: [
                    Text(
                      weekDaysNames[dayLabelIndex],
                      style: theme.textTheme.labelMedium?.copyWith(
                        fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
                        color: isToday ? Colors.orange : theme.hintColor,
                      ),
                    ),
                    const Gap(12),
                    AnimatedContainer(
                      duration: const Duration(milliseconds: 300),
                      width: 28,
                      height: 28,
                      decoration: BoxDecoration(
                        color: isRecorded
                            ? Colors.orange
                            : Colors.orange.withValues(alpha: 0.1),
                        shape: BoxShape.circle,
                        border: isToday
                            ? Border.all(color: Colors.orange, width: 2)
                            : null,
                      ),
                      child: isRecorded
                          ? const Icon(Icons.check_rounded,
                          size: 16, color: Colors.white)
                          : null,
                    ),
                  ],
                );
              }),
            ),
            const Gap(40),
            Text(
              streak > 0 ? l10n.streakLongMessage(streak) : l10n.addMemory,
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyMedium?.copyWith(
                fontStyle: FontStyle.italic,
                color:
                theme.textTheme.bodyMedium?.color?.withValues(alpha: 0.8),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/add_entry_screen.dart:
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:gap/gap.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import 'package:drift/drift.dart' show InsertMode;

import '../../../../l10n/app_localizations.dart';
import '../../../core/database/database.dart';
import '../../../core/providers/locale_provider.dart';
import '../../../core/utils/logger_service.dart';
import '../../../core/utils/weather_service.dart';
import '../data/journal_repository.dart';
import '../data/models/journal_entry.dart';
import 'widgets/camera/custom_camera_screen.dart';

/// A screen for creating a new journal entry or editing an existing one.
class AddEntryScreen extends ConsumerStatefulWidget {
  final JournalEntry? entry;
  final DateTime? initialDate;
  final String? initialImagePath;

  const AddEntryScreen({super.key, this.entry, this.initialDate, this.initialImagePath});

  @override
  ConsumerState<AddEntryScreen> createState() => _AddEntryScreenState();
}

class _AddEntryScreenState extends ConsumerState<AddEntryScreen> {
  String? _imagePath;
  int _mood = 3;
  String? _location;
  String? _weatherTemp;
  String? _weatherIcon;

  // Flag to track if the source image is temporary (from camera)
  bool _isImageTemporary = false;

  late final TextEditingController _noteController;
  bool _isSaving = false;
  bool _isLoadingMetadata = false;

  @override
  void initState() {
    super.initState();
    _noteController = TextEditingController(text: widget.entry?.note ?? '');

    if (widget.entry != null) {
      _imagePath = widget.entry!.photoPath;
      _mood = widget.entry!.moodRating;
      _location = widget.entry!.location;
      _weatherTemp = widget.entry!.weatherTemp;
      _weatherIcon = widget.entry!.weatherIcon;
    } else if (widget.initialImagePath != null) {
      _imagePath = widget.initialImagePath;
      // Assume images passed directly are from the camera (temporary)
      _isImageTemporary = true;
    }
  }

  @override
  void dispose() {
    _noteController.dispose();
    super.dispose();
  }

  Future<void> _fetchMetadata() async {
    Logger.info('Attempting to fetch location and weather metadata.');
    final l10n = AppLocalizations.of(context)!;
    setState(() => _isLoadingMetadata = true);

    try {
      await Geolocator.isLocationServiceEnabled();
      LocationPermission permission = await Geolocator.checkPermission();

      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          Logger.warning('User denied location permission.');
          _showErrorSnackBar(l10n.locationPermissionDenied);
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        Logger.warning('User has permanently denied location permission.');
        if (mounted) {
          showDialog(
            context: context,
            builder: (context) => AlertDialog(
              title: Text(l10n.locationPermissionDenied),
              content: Text(l10n.enableLocationMessage),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: Text(l10n.cancel),
                ),
                TextButton(
                  onPressed: () {
                    Logger.info('User tapped "Open Settings" for location permission.');
                    Navigator.pop(context);
                    Geolocator.openAppSettings();
                  },
                  child: Text(l10n.openSettings),
                ),
              ],
            ),
          );
        }
        return;
      }

      final position = await Geolocator.getCurrentPosition(
        locationSettings: const LocationSettings(accuracy: LocationAccuracy.low),
      ).timeout(const Duration(seconds: 15));
      Logger.debug('Successfully retrieved GPS position: ${position.latitude}, ${position.longitude}');

      try {
        final langCode = ref.read(localeProvider).languageCode;
        await setLocaleIdentifier(langCode);

        final placemarks = await placemarkFromCoordinates(
          position.latitude,
          position.longitude,
        );

        if (placemarks.isNotEmpty) {
          final p = placemarks.first;
          setState(() => _location = "${p.locality}, ${p.administrativeArea}");
        }

        final weatherData = await ref.read(weatherServiceProvider).fetchWeather(
          lat: position.latitude,
          lon: position.longitude,
          langCode: langCode,
        );

        setState(() {
          _weatherTemp = weatherData.temperature;
          _weatherIcon = weatherData.iconCode;
        });
        Logger.debug('Successfully fetched metadata. Location: $_location, Weather: $_weatherTemp');
      } on SocketException catch (e, stack) {
        Logger.error('Network error while fetching metadata.', e, stack);
        _showErrorSnackBar(l10n.noInternetError);
      } catch (e, stack) {
        Logger.error('Failed to fetch geocoding or weather data.', e, stack);
      }
    } catch (e, stack) {
      Logger.error('Failed to get device location.', e, stack);
      _showErrorSnackBar(l10n.locationDisabled);
    } finally {
      if (mounted) setState(() => _isLoadingMetadata = false);
    }
  }

  void _showErrorSnackBar(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        behavior: SnackBarBehavior.floating,
        backgroundColor: Theme.of(context).colorScheme.error,
      ),
    );
  }

  /// Validates and persists the journal entry to the local database.
  Future<void> _saveEntry() async {
    if (_imagePath == null) return;

    Logger.info('User initiated save for journal entry.');
    setState(() => _isSaving = true);
    HapticFeedback.mediumImpact();

    try {
      final repo = ref.read(journalRepositoryProvider);
      final db = ref.read(databaseProvider);
      final entryDate = widget.initialDate ?? widget.entry?.date ?? DateTime.now();

      final journalEntry = JournalEntry(
        id: widget.entry?.id,
        date: entryDate,
        photoPath: _imagePath!,
        thumbnailPath: widget.entry?.thumbnailPath,
        moodRating: _mood,
        note: _noteController.text,
        location: _location,
        weatherTemp: _weatherTemp,
        weatherIcon: _weatherIcon,
      );

      if (widget.entry != null) {
        final bool imageChanged = _imagePath != widget.entry!.photoPath;
        Logger.info('Updating existing entry ID: ${widget.entry!.id}. Image changed: $imageChanged');
        await repo.updateEntry(
          journalEntry,
          newTempPath: imageChanged ? _imagePath : null,
          deleteSource: imageChanged ? _isImageTemporary : false,
        );
      } else {
        Logger.info('Adding new entry.');
        await repo.addEntry(journalEntry, _imagePath!, deleteSource: _isImageTemporary);
      }

      final normalizedDate = DateTime(entryDate.year, entryDate.month, entryDate.day);
      await db.into(db.activityLog).insert(
        ActivityLogCompanion.insert(date: normalizedDate),
        mode: InsertMode.insertOrIgnore,
      );
      Logger.info('Activity log updated for date: $normalizedDate');

      if (mounted) Navigator.pop(context, true);
    } catch (e, stack) {
      Logger.error('Failed to save journal entry.', e, stack);
      if (mounted) {
        _showErrorSnackBar("Error: ${e.toString()}");
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          widget.entry != null ? l10n.editEntry : l10n.moodTitle,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        leading: IconButton(
          icon: const Icon(Icons.close_rounded),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _PhotoPlaceholder(
              imagePath: _imagePath,
              heroTag: widget.entry != null ? 'photo_${widget.entry!.id}' : 'add_photo',
              onTap: () => _showImageSourceSheet(context, l10n),
            ),
            const Gap(24),
            Text(l10n.myMood, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
            const Gap(12),
            _MoodSelector(
              currentMood: _mood,
              onMoodSelected: (val) {
                Logger.info('Mood changed to: $val');
                setState(() => _mood = val);
              },
            ),
            const Gap(24),
            IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: _MetadataCard(
                      icon: Icons.location_on_rounded,
                      label: _location ?? l10n.addLocation,
                      isSelected: _location != null,
                      onTap: _fetchMetadata,
                      isLoading: _isLoadingMetadata,
                    ),
                  ),
                  const Gap(12),
                  Expanded(
                    child: _MetadataCard(
                      icon: Icons.wb_cloudy_rounded,
                      label: _weatherTemp ?? l10n.addWeather,
                      isSelected: _weatherTemp != null,
                      onTap: _fetchMetadata,
                      isLoading: _isLoadingMetadata,
                      weatherIcon: _weatherIcon,
                    ),
                  ),
                ],
              ),
            ),
            const Gap(24),
            Text(l10n.noteHint, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
            const Gap(12),
            TextField(
              controller: _noteController,
              maxLines: 4,
              textCapitalization: TextCapitalization.sentences,
              decoration: InputDecoration(
                filled: true,
                fillColor: colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
                hintText: l10n.writeMemory,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(24),
                  borderSide: BorderSide.none,
                ),
              ),
            ),
            const Gap(40),
            SizedBox(
              width: double.infinity,
              height: 60,
              child: FilledButton(
                onPressed: _isSaving || _imagePath == null ? null : _saveEntry,
                style: FilledButton.styleFrom(
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                  backgroundColor: colorScheme.primary,
                  foregroundColor: colorScheme.onPrimary,
                ),
                child: _isSaving
                    ? const SizedBox(width: 24, height: 24, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2.5))
                    : Text(l10n.saveDay, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              ),
            ),
            const Gap(24),
          ],
        ),
      ),
    );
  }

  /// Displays a modal bottom sheet for selecting an image source.
  void _showImageSourceSheet(BuildContext context, AppLocalizations l10n) {
    Logger.info('Showing image source selection sheet.');
    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(32))),
      builder: (context) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.only(bottom: 20, left: 12, right: 12),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.camera_alt_rounded),
                title: Text(l10n.camera),
                onTap: () async {
                  Navigator.pop(context);
                  Logger.info('User selected "Camera" as image source.');
                  final String? photoPath = await Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const CustomCameraScreen()),
                  );
                  if (photoPath != null) {
                    Logger.info('Image captured from camera: $photoPath');
                    _handleNewImage(photoPath, isTemporary: true);
                  } else {
                    Logger.info('Camera action was cancelled by user.');
                  }
                },
              ),
              ListTile(
                leading: const Icon(Icons.photo_library_rounded),
                title: Text(l10n.gallery),
                onTap: () async {
                  Navigator.pop(context);
                  Logger.info('User selected "Gallery" as image source.');
                  final picker = ImagePicker();
                  final photo = await picker.pickImage(source: ImageSource.gallery, imageQuality: 80);
                  if (photo != null) {
                    Logger.info('Image picked from gallery: ${photo.path}');
                    _handleNewImage(photo.path, isTemporary: false);
                  } else {
                    Logger.info('Gallery picking was cancelled by user.');
                  }
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Updates the UI with the new image path and its temporary status.
  void _handleNewImage(String path, {required bool isTemporary}) {
    setState(() {
      _imagePath = path;
      _isImageTemporary = isTemporary;
    });
  }
}

/// A widget that displays the selected photo or a placeholder to add one.
class _PhotoPlaceholder extends StatelessWidget {
  /// The local file path of the image to display. If null, a placeholder is shown.
  final String? imagePath;
  /// The Hero animation tag for the photo, ensuring a smooth transition.
  final String heroTag;
  /// The callback function to execute when the placeholder is tapped.
  final VoidCallback onTap;

  /// Creates a photo placeholder widget.
  const _PhotoPlaceholder({required this.imagePath, required this.heroTag, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return GestureDetector(
      onTap: onTap,
      child: Hero(
        tag: heroTag,
        child: AspectRatio(
          aspectRatio: 1,
          child: Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(32),
              border: Border.all(color: colorScheme.primary.withValues(alpha: 0.1)),
              image: imagePath != null
                  ? DecorationImage(
                  image: FileImage(File(imagePath!)),
                  fit: BoxFit.cover
              )
                  : null,
            ),
            child: imagePath == null
                ? Center(child: Icon(Icons.add_a_photo_outlined, size: 48, color: colorScheme.primary))
                : const SizedBox.shrink(),
          ),
        ),
      ),
    );
  }
}

/// A horizontal selector for choosing a mood rating from 1 to 5.
class _MoodSelector extends StatelessWidget {
  /// The currently selected mood rating (1-5).
  final int currentMood;
  /// A callback that is invoked with the new rating when a mood is selected.
  final ValueChanged<int> onMoodSelected;

  /// Creates a mood selector widget.
  const _MoodSelector({required this.currentMood, required this.onMoodSelected});

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final emojis = ['😢', '🙁', '😐', '🙂', '🤩'];

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: List.generate(5, (index) {
        int rating = index + 1;
        bool isSelected = currentMood == rating;
        return GestureDetector(
          onTap: () {
            HapticFeedback.lightImpact();
            onMoodSelected(rating);
          },
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 250),
            padding: const EdgeInsets.all(14),
            decoration: BoxDecoration(
              color: isSelected ? colorScheme.primary : colorScheme.surfaceContainerHigh,
              borderRadius: BorderRadius.circular(20),
              boxShadow: isSelected
                  ? [BoxShadow(color: colorScheme.primary.withValues(alpha: 0.3), blurRadius: 8, offset: const Offset(0, 4))]
                  : null,
            ),
            child: Text(emojis[index], style: const TextStyle(fontSize: 30)),
          ),
        );
      }),
    );
  }
}

/// A card for displaying and fetching metadata like location or weather.
class _MetadataCard extends StatelessWidget {
  /// The icon representing the type of metadata.
  final IconData icon;
  /// The text label displaying the metadata value or a prompt.
  final String label;
  /// A boolean indicating if the metadata has been successfully fetched.
  final bool isSelected;
  /// The callback function to execute when the card is tapped to fetch data.
  final VoidCallback onTap;
  /// A boolean to show a loading indicator while data is being fetched.
  final bool isLoading;
  /// An optional URL for a weather icon to display instead of the default [icon].
  final String? weatherIcon;

  /// Creates a metadata card widget.
  const _MetadataCard({
    required this.icon,
    required this.label,
    required this.isSelected,
    required this.onTap,
    this.isLoading = false,
    this.weatherIcon,
  });

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: isLoading ? null : onTap,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        height: 64,
        alignment: Alignment.centerLeft,
        padding: const EdgeInsets.symmetric(horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? colorScheme.primary.withValues(alpha: 0.08) : colorScheme.surfaceContainerLow,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isSelected ? colorScheme.primary.withValues(alpha: 0.3) : colorScheme.outlineVariant.withValues(alpha: 0.3),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.max,
          children: [
            SizedBox(
              width: 28,
              height: 28,
              child: Center(
                child: isLoading
                    ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2.5,
                    color: colorScheme.primary,
                  ),
                )
                    : weatherIcon != null
                    ? Image.network(
                  'https://openweathermap.org/img/wn/$weatherIcon@2x.png',
                  width: 28,
                  height: 28,
                  errorBuilder: (_, __, ___) => Icon(icon, size: 20),
                )
                    : Icon(
                  icon,
                  size: 20,
                  color: isSelected ? colorScheme.primary : colorScheme.onSurfaceVariant,
                ),
              ),
            ),
            const Gap(12),
            Expanded(
              child: Text(
                label,
                style: TextStyle(
                  fontSize: 13,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                  color: isSelected ? colorScheme.primary : colorScheme.onSurfaceVariant,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/entry_detail_screen.dart:
import 'dart:io';
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:gal/gal.dart';
import 'package:gap/gap.dart';

import '../../../../l10n/app_localizations.dart';
import '../../../core/utils/logger_service.dart';
import '../data/journal_repository.dart';
import '../data/models/journal_entry.dart';
import 'add_entry_screen.dart';

/// A screen that displays the full details of a single [JournalEntry].
///
/// This screen provides a rich view of the entry's photo, mood, metadata, and note.
/// It also offers actions to edit, delete, or export the entry's photo.
class EntryDetailScreen extends ConsumerWidget {
  /// The journal entry to be displayed.
  final JournalEntry entry;

  /// Creates the detail screen for a journal entry.
  const EntryDetailScreen({super.key, required this.entry});

  /// Navigates to a full-screen, interactive viewer for the entry's photo.
  void _showFullScreenImage(BuildContext context) {
    Logger.info('Showing full-screen image for entry ID: ${entry.id}');
    Navigator.push(
      context,
      PageRouteBuilder(
        opaque: false,
        barrierColor: Colors.black,
        pageBuilder: (context, _, __) => _FullScreenImageViewer(entry: entry),
      ),
    );
  }

  /// Saves the entry's photo to the device's native photo gallery.
  ///
  /// Shows a success or error [SnackBar] upon completion.
  Future<void> _saveToGallery(BuildContext context, AppLocalizations l10n) async {
    Logger.info('Attempting to save image to gallery for entry ID: ${entry.id}');
    try {
      await Gal.putImage(entry.photoPath);
      Logger.info('Successfully saved image to gallery for entry ID: ${entry.id}');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(l10n.saveGallerySuccess),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
        ));
      }
    } catch (e, stack) {
      Logger.error('Failed to save image to gallery.', e, stack);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.errorExport(e.toString()))),
        );
      }
    }
  }

  /// Displays a confirmation dialog before permanently deleting the journal entry.
  void _showDeleteDialog(BuildContext context, AppLocalizations l10n, WidgetRef ref) {
    Logger.info('Delete dialog opened for entry ID: ${entry.id}');
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(l10n.deleteEntryTitle),
        content: Text(l10n.deleteEntryDesc),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(l10n.cancel)),
          TextButton(
            onPressed: () async {
              Logger.info('User confirmed deletion for entry ID: ${entry.id}');
              try {
                await ref.read(journalRepositoryProvider).deleteEntry(entry);
                if (context.mounted) {
                  Navigator.pop(context); // Close dialog
                  Navigator.pop(context); // Go back from detail screen
                }
              } catch (e, stack) {
                Logger.error('Failed to delete entry ID: ${entry.id}', e, stack);
                if (context.mounted) {
                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error: Could not delete entry.')),
                  );
                }
              }
            },
            child: Text(l10n.delete, style: const TextStyle(color: Colors.red, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    Logger.info('Building EntryDetailScreen for entry ID: ${entry.id}');
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).languageCode;

    final rawDate = DateFormat('EEEE, d MMMM yyyy', locale).format(entry.date);
    final formattedDate = rawDate[0].toUpperCase() + rawDate.substring(1);
    final formattedTime = DateFormat('HH:mm', locale).format(entry.date);
    final bool showTime = entry.date.hour != 0 || entry.date.minute != 0;

    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;
    final double bottomContentPadding = systemBottomPadding > 0
        ? systemBottomPadding + 24
        : 40.0;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: _AppBarCircleAction(child: const BackButton(color: Colors.white)),
        actions: [
          _AppBarCircleAction(
            child: IconButton(
              icon: const Icon(Icons.download_rounded, color: Colors.white, size: 20),
              onPressed: () => _saveToGallery(context, l10n),
            ),
          ),
          _AppBarCircleAction(
            child: IconButton(
              icon: const Icon(Icons.edit_outlined, color: Colors.white, size: 20),
              onPressed: () async {
                Logger.info('Navigating to edit screen for entry ID: ${entry.id}');
                final bool? refresh = await Navigator.push(
                  context,
                  MaterialPageRoute(builder: (_) => AddEntryScreen(entry: entry)),
                );
                if (refresh == true && context.mounted) Navigator.pop(context);
              },
            ),
          ),
          _AppBarCircleAction(
            child: IconButton(
              icon: const Icon(Icons.delete_outline, color: Colors.white, size: 20),
              onPressed: () => _showDeleteDialog(context, l10n, ref),
            ),
          ),
          const Gap(8),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          children: [
            _ParallaxHeader(
              entry: entry,
              dateText: formattedDate,
              timeText: showTime ? formattedTime : null,
              onTap: () => _showFullScreenImage(context),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(24, 24, 24, bottomContentPadding),
              child: Column(
                children: [
                  _MoodCard(entry: entry, l10n: l10n),
                  const Gap(16),
                  _MetadataRow(entry: entry),
                  const Gap(32),
                  _NoteContainer(entry: entry, l10n: l10n),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// A private widget that wraps an action icon in a semi-transparent circular background.
class _AppBarCircleAction extends StatelessWidget {
  /// The child widget, typically an [IconButton].
  final Widget child;

  /// Creates a styled circular action for the app bar.
  const _AppBarCircleAction({required this.child});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(6.0),
      child: CircleAvatar(
        backgroundColor: Colors.black.withValues(alpha: 0.2),
        child: child,
      ),
    );
  }
}

/// The main header widget displaying the entry's photo with a parallax-like effect.
///
/// It includes an optimized image loading strategy that shows a low-resolution
/// thumbnail instantly while the high-resolution image fades in.
class _ParallaxHeader extends StatelessWidget {
  /// The entry containing the photo to display.
  final JournalEntry entry;
  /// The formatted date string to overlay on the image.
  final String dateText;
  /// The optional formatted time string to overlay on the image.
  final String? timeText;
  /// The callback executed when the header is tapped.
  final VoidCallback onTap;

  /// Creates the parallax header.
  const _ParallaxHeader({
    required this.entry,
    required this.dateText,
    this.timeText,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final int screenWidth = (MediaQuery.of(context).size.width * MediaQuery.of(context).devicePixelRatio).round();

    return GestureDetector(
      onTap: onTap,
      child: Stack(
        children: [
          Hero(
            tag: 'photo_${entry.id}',
            child: Container(
              height: MediaQuery.of(context).size.height * 0.48,
              width: double.infinity,
              decoration: const BoxDecoration(
                borderRadius: BorderRadius.vertical(bottom: Radius.circular(40)),
                color: Colors.black12,
              ),
              child: ClipRRect(
                borderRadius: const BorderRadius.vertical(bottom: Radius.circular(40)),
                child: Image.file(
                  File(entry.photoPath),
                  fit: BoxFit.cover,
                  cacheWidth: screenWidth,
                  frameBuilder: (context, child, frame, wasSynchronouslyLoaded) {
                    if (wasSynchronouslyLoaded) return child;

                    return Stack(
                      fit: StackFit.expand,
                      children: [
                        if (entry.thumbnailPath != null && entry.thumbnailPath!.isNotEmpty)
                          Image.file(
                            File(entry.thumbnailPath!),
                            fit: BoxFit.cover,
                            gaplessPlayback: true,
                          ),
                        AnimatedOpacity(
                          opacity: frame == null ? 0 : 1,
                          duration: const Duration(milliseconds: 250),
                          curve: Curves.easeOut,
                          child: child,
                        ),
                      ],
                    );
                  },
                ),
              ),
            ),
          ),
          Positioned.fill(
            child: DecoratedBox(
              decoration: BoxDecoration(
                borderRadius: const BorderRadius.vertical(bottom: Radius.circular(40)),
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.black.withValues(alpha: 0.2),
                    Colors.transparent,
                    Colors.black.withValues(alpha: 0.8),
                  ],
                ),
              ),
            ),
          ),
          Positioned(
            bottom: 24,
            left: 24,
            right: 24,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  dateText,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 26,
                    fontWeight: FontWeight.w900,
                    shadows: [Shadow(blurRadius: 10, color: Colors.black45)],
                  ),
                ),
                if (timeText != null) ...[
                  const Gap(4),
                  Row(
                    children: [
                      const Icon(Icons.access_time_filled_rounded, color: Colors.white70, size: 14),
                      const Gap(6),
                      Text(
                        timeText!,
                        style: const TextStyle(color: Colors.white70, fontWeight: FontWeight.w600),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }
}

/// A card that displays the mood rating of the entry with a corresponding emoji.
class _MoodCard extends StatelessWidget {
  /// The entry from which to derive the mood.
  final JournalEntry entry;
  /// The localization instance for displaying labels.
  final AppLocalizations l10n;

  /// Creates a card for displaying the mood.
  const _MoodCard({required this.entry, required this.l10n});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final emojis = ['😢', '🙁', '😐', '🙂', '🤩'];
    final emoji = emojis[entry.moodRating.clamp(1, 5) - 1];

    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: theme.colorScheme.primary.withValues(alpha: 0.05),
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: theme.colorScheme.primary.withValues(alpha: 0.1)),
      ),
      child: Row(
        children: [
          Text(emoji, style: const TextStyle(fontSize: 40)),
          const Gap(16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.moodLabel,
                style: theme.textTheme.labelSmall?.copyWith(
                  color: theme.colorScheme.onSurface.withValues(alpha: 0.5),
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                l10n.myMood,
                style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w900),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// A row that conditionally displays metadata cards for location and weather.
class _MetadataRow extends StatelessWidget {
  /// The entry containing the metadata to display.
  final JournalEntry entry;

  /// Creates a row for displaying metadata.
  const _MetadataRow({required this.entry});

  @override
  Widget build(BuildContext context) {
    if (entry.location == null && entry.weatherTemp == null) return const SizedBox.shrink();
    return Row(
      children: [
        if (entry.location != null)
          Expanded(child: _AutoMarqueeCard(icon: Icons.location_on_rounded, text: entry.location!)),
        if (entry.location != null && entry.weatherTemp != null) const Gap(8),
        if (entry.weatherTemp != null)
          Expanded(child: _AutoMarqueeCard(
            icon: Icons.wb_cloudy_rounded,
            text: entry.weatherTemp!,
            weatherIcon: entry.weatherIcon,
          )),
      ],
    );
  }
}

/// A styled container that displays the user's note for the journal entry.
class _NoteContainer extends StatelessWidget {
  /// The entry containing the note to display.
  final JournalEntry entry;
  /// The localization instance for labels and fallbacks.
  final AppLocalizations l10n;

  /// Creates a container for the journal note.
  const _NoteContainer({required this.entry, required this.l10n});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(32),
        border: Border.all(color: theme.colorScheme.outlineVariant.withValues(alpha: 0.4)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 20,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.auto_awesome_rounded, size: 16, color: theme.colorScheme.primary),
              const Gap(12),
              Text(
                l10n.journal.toUpperCase(),
                style: theme.textTheme.labelLarge?.copyWith(
                  color: theme.colorScheme.primary,
                  fontWeight: FontWeight.w900,
                  letterSpacing: 1.5,
                ),
              ),
            ],
          ),
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 20),
            child: Divider(height: 1),
          ),
          Text(
            entry.note ?? l10n.noNote,
            style: theme.textTheme.bodyLarge?.copyWith(
              height: 1.7,
              color: theme.colorScheme.onSurface.withValues(alpha: 0.8),
            ),
          ),
        ],
      ),
    );
  }
}

/// A full-screen, zoomable viewer for the entry's photo.
class _FullScreenImageViewer extends StatelessWidget {
  /// The entry whose photo will be displayed.
  final JournalEntry entry;

  /// Creates a full-screen image viewer.
  const _FullScreenImageViewer({required this.entry});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: const CloseButton(color: Colors.white),
      ),
      body: SizedBox.expand(
        child: InteractiveViewer(
          minScale: 0.5,
          maxScale: 4.0,
          child: Hero(
            tag: 'photo_${entry.id}',
            child: Image.file(File(entry.photoPath), fit: BoxFit.contain),
          ),
        ),
      ),
    );
  }
}

/// A card with auto-scrolling text, used for displaying potentially long metadata.
class _AutoMarqueeCard extends StatefulWidget {
  /// The icon to display next to the text.
  final IconData icon;
  /// The text content to display and scroll.
  final String text;
  /// An optional weather icon URL to display instead of the default icon.
  final String? weatherIcon;

  /// Creates a card with auto-scrolling text.
  const _AutoMarqueeCard({required this.icon, required this.text, this.weatherIcon});

  @override
  State<_AutoMarqueeCard> createState() => _AutoMarqueeCardState();
}

class _AutoMarqueeCardState extends State<_AutoMarqueeCard> {
  late ScrollController _scrollController;
  Timer? _timer;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    WidgetsBinding.instance.addPostFrameCallback((_) => _startScrolling());
  }

  /// Initiates the periodic scrolling animation if the text overflows.
  void _startScrolling() {
    if (!mounted || !_scrollController.hasClients) return;
    final maxScroll = _scrollController.position.maxScrollExtent;
    if (maxScroll <= 0) return;

    _timer = Timer.periodic(const Duration(seconds: 3), (timer) async {
      if (!mounted || !_scrollController.hasClients) return;
      await _scrollController.animateTo(maxScroll, duration: Duration(milliseconds: maxScroll.toInt() * 65), curve: Curves.linear);
      await Future.delayed(const Duration(seconds: 1));
      if (!mounted || !_scrollController.hasClients) return;
      await _scrollController.animateTo(0, duration: const Duration(milliseconds: 1000), curve: Curves.easeOut);
    });
  }

  @override
  void dispose() {
    _timer?.cancel();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      height: 54,
      padding: const EdgeInsets.symmetric(horizontal: 14),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: theme.colorScheme.outlineVariant.withValues(alpha: 0.5)),
      ),
      child: Row(
        children: [
          if (widget.weatherIcon != null)
            Image.network('https://openweathermap.org/img/wn/${widget.weatherIcon}.png', width: 28, height: 28)
          else
            Icon(widget.icon, size: 18, color: theme.colorScheme.primary),
          const Gap(10),
          Expanded(
            child: SingleChildScrollView(
              controller: _scrollController,
              scrollDirection: Axis.horizontal,
              physics: const NeverScrollableScrollPhysics(),
              child: Text(
                widget.text,
                style: theme.textTheme.labelLarge?.copyWith(fontWeight: FontWeight.w700),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

lib/src/features/journal/presentation/home_screen.dart:
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';
import 'package:drift/drift.dart' as drift;

import '../../../core/database/database.dart';
import '../../../core/providers/streak_provider.dart';
import '../../../core/providers/theme_provider.dart';
import '../../../core/utils/logger_service.dart';
import '../../../../l10n/app_localizations.dart';

import '../data/models/journal_entry.dart';
import 'add_entry_screen.dart';
import 'widgets/journal_grid.dart';
import 'widgets/quote_card.dart';
import 'widgets/streak_card.dart';

/// Provides a real-time stream of all [JournalEntry] items from the database.
///
/// The entries are sorted in descending chronological order, ensuring the most
/// recent memories appear first.
final journalStreamProvider = StreamProvider<List<JournalEntry>>((ref) {
  final db = ref.watch(databaseProvider);
  final query = db.select(db.dayEntries)
    ..orderBy([(t) => drift.OrderingTerm.desc(t.date)]);

  return query.watch().map((rows) => rows.map((row) => JournalEntry.fromDrift(row)).toList());
});

/// The main screen of the application, serving as the central hub for the user.
///
/// It displays a persistent header with streak information, a daily quote, and
/// a grid of all journal entries. It also handles loading, error, and empty states.
class HomeScreen extends ConsumerStatefulWidget {
  /// Creates the main home screen.
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

/// Manages the state for the [HomeScreen], primarily handling the scroll
/// controller to implement a "back to top" button.
class _HomeScreenState extends ConsumerState<HomeScreen> {
  /// Controls the scrolling of the main content to detect scroll offset.
  late final ScrollController _scrollController;

  /// Notifies listeners when the "back to top" button should be visible.
  final ValueNotifier<bool> _showBackToTopNotifier = ValueNotifier<bool>(false);

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _scrollController.addListener(_scrollListener);
  }

  /// Listens to scroll events to toggle the visibility of the back-to-top button.
  ///
  /// The button becomes visible after scrolling down a certain threshold.
  void _scrollListener() {
    if (!_scrollController.hasClients) return;
    final bool shouldShow = _scrollController.offset > 400;
    if (shouldShow != _showBackToTopNotifier.value) {
      _showBackToTopNotifier.value = shouldShow;
    }
  }

  @override
  void dispose() {
    _scrollController.removeListener(_scrollListener);
    _scrollController.dispose();
    _showBackToTopNotifier.dispose();
    super.dispose();
  }

  /// Animates the scroll position back to the top of the page.
  void _scrollToTop() {
    Logger.info('User tapped "Back to Top" button.');
    HapticFeedback.mediumImpact();
    if (_scrollController.hasClients) {
      _scrollController.animateTo(0, duration: const Duration(milliseconds: 600), curve: Curves.fastOutSlowIn);
    }
  }

  @override
  Widget build(BuildContext context) {
    final journalAsync = ref.watch(journalStreamProvider);
    final l10n = AppLocalizations.of(context)!;
    final streakState = ref.watch(streakProvider);

    final double topPadding = MediaQuery.paddingOf(context).top;
    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;
    const double dockHeight = 72.0;
    final double dockBottomMargin = systemBottomPadding > 0 ? systemBottomPadding + 20 : 24.0;
    final double dockTopEdge = dockHeight + dockBottomMargin;
    final double fabPadding = (dockTopEdge + 16.0) - systemBottomPadding;
    final double contentBottomPadding = dockTopEdge + 24.0;

    return Scaffold(
      floatingActionButton: ValueListenableBuilder<bool>(
        valueListenable: _showBackToTopNotifier,
        builder: (context, visible, _) {
          return _BackToTopButton(isVisible: visible, onPressed: _scrollToTop, bottomOffset: fabPadding);
        },
      ),
      body: journalAsync.when(
        loading: () => _buildLoadingShimmer(),
        data: (entries) {
          return CustomScrollView(
            controller: _scrollController,
            physics: const BouncingScrollPhysics(),
            slivers: [
              SliverPersistentHeader(
                pinned: true,
                delegate: _HeaderDelegate(
                  streakCount: streakState.count,
                  activeDates: streakState.activeDates,
                  topPadding: topPadding,
                  onToggleTheme: () {
                    Logger.info('User toggled theme.');
                    HapticFeedback.selectionClick();
                    ref.read(themeNotifierProvider.notifier).toggleTheme();
                  },
                ),
              ),
              const SliverToBoxAdapter(
                child: Padding(
                  padding: EdgeInsets.fromLTRB(24, 8, 24, 24),
                  child: QuoteCard(),
                ),
              ),
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 8),
                  child: Text(
                    l10n.yourMemories,
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900, letterSpacing: -0.5),
                  ),
                ),
              ),
              if (entries.isEmpty)
                SliverFillRemaining(hasScrollBody: false, child: _EmptyJournalState(l10n: l10n))
              else
                ...JournalGrid.sliversFor(entries, context),
              SliverGap(contentBottomPadding),
            ],
          );
        },
        error: (err, st) {
          Logger.error('Failed to load journal stream.', err, st);
          return CustomScrollView(
            physics: const BouncingScrollPhysics(),
            slivers: [
              SliverPersistentHeader(
                pinned: true,
                delegate: _HeaderDelegate(
                  streakCount: streakState.count,
                  activeDates: streakState.activeDates,
                  topPadding: topPadding,
                  onToggleTheme: () {
                    Logger.info('User toggled theme.');
                    HapticFeedback.selectionClick();
                    ref.read(themeNotifierProvider.notifier).toggleTheme();
                  },
                ),
              ),
              SliverFillRemaining(
                hasScrollBody: false,
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.error_outline, size: 48, color: Theme.of(context).colorScheme.error),
                      const Gap(16),
                      Text(l10n.loadingError),
                      const Gap(16),
                      ElevatedButton(
                          onPressed: () {
                            Logger.info('User tapped "Retry" on journal stream error.');
                            // Explicitly discard the result to satisfy 'unused_result' warning.
                            final _ = ref.refresh(journalStreamProvider);
                          },
                          child: Text(l10n.retry)),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  /// Builds a shimmer loading placeholder widget to indicate that content is being fetched.
  Widget _buildLoadingShimmer() {
    return ListView.builder(
      itemCount: 6,
      padding: const EdgeInsets.all(20),
      itemBuilder: (context, index) {
        return Padding(
          padding: const EdgeInsets.only(bottom: 24),
          child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
            Container(height: 20, width: 150, decoration: BoxDecoration(color: Colors.grey.withValues(alpha: 0.2), borderRadius: BorderRadius.circular(4))),
            const Gap(16),
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3, crossAxisSpacing: 8, mainAxisSpacing: 8, childAspectRatio: 0.85),
              itemCount: 9,
              itemBuilder: (context, idx) => Container(decoration: BoxDecoration(color: Colors.grey.withValues(alpha: 0.2), borderRadius: BorderRadius.circular(12))),
            ),
          ]),
        );
      },
    );
  }
}

/// A small, animated Floating Action Button that appears when the user scrolls down.
///
/// Tapping it scrolls the view back to the top.
class _BackToTopButton extends StatelessWidget {
  /// Determines if the button is currently visible.
  final bool isVisible;
  /// The callback function executed when the button is pressed.
  final VoidCallback onPressed;
  /// The vertical offset from the bottom of the screen.
  final double bottomOffset;

  /// Creates a back-to-top button.
  const _BackToTopButton({required this.isVisible, required this.onPressed, required this.bottomOffset});

  @override
  Widget build(BuildContext context) {
    return AnimatedScale(
      scale: isVisible ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOutBack,
      child: Padding(
        padding: EdgeInsets.only(bottom: bottomOffset),
        child: FloatingActionButton.small(
          onPressed: onPressed,
          backgroundColor: Theme.of(context).colorScheme.primary,
          elevation: 4,
          shape: const CircleBorder(),
          child: const Icon(Icons.arrow_upward_rounded, color: Colors.white),
        ),
      ),
    );
  }
}

/// A widget displayed in the center of the screen when the journal is empty.
///
/// It provides a message and a call-to-action button to create the first entry.
class _EmptyJournalState extends StatelessWidget {
  /// The localization instance for displaying text.
  final AppLocalizations l10n;

  /// Creates the empty state widget.
  const _EmptyJournalState({required this.l10n});

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.all(40),
      child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
        Container(padding: const EdgeInsets.all(28), decoration: BoxDecoration(color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.3), shape: BoxShape.circle), child: Icon(Icons.auto_stories_rounded, size: 64, color: colorScheme.secondary)),
        const Gap(24),
        Text(l10n.emptyJournalTitle, style: const TextStyle(fontSize: 20, fontWeight: FontWeight.w900), textAlign: TextAlign.center),
        const Gap(8),
        Text(l10n.emptyJournalMessage, style: TextStyle(color: colorScheme.onSurfaceVariant), textAlign: TextAlign.center),
        const Gap(32),
        FilledButton.icon(
          onPressed: () {
            Logger.info('User tapped "Create Memory" from empty state.');
            Navigator.push(context, MaterialPageRoute(builder: (_) => const AddEntryScreen()));
          },
          icon: const Icon(Icons.add_rounded),
          label: Text(l10n.createMemory),
          style: FilledButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20))),
        ),
      ]),
    );
  }
}

/// A custom [SliverPersistentHeaderDelegate] for the home screen's app bar.
///
/// It displays the app title, a theme toggle button, and the [StreakCard].
/// The background becomes semi-opaque with a shadow when scrolled.
class _HeaderDelegate extends SliverPersistentHeaderDelegate {
  /// The user's current streak count.
  final int streakCount;
  /// The list of dates with journal entries, used by the [StreakCard].
  final List<DateTime> activeDates;
  /// The height of the top safe area (status bar/notch).
  final double topPadding;
  /// The callback function to execute when the theme toggle button is pressed.
  final VoidCallback onToggleTheme;

  /// Creates the header delegate.
  _HeaderDelegate({
    required this.streakCount,
    required this.activeDates,
    required this.topPadding,
    required this.onToggleTheme,
  });

  @override
  Widget build(BuildContext context, double shrinkOffset, bool overlapsContent) {
    final bool isScrolled = shrinkOffset > 0 || overlapsContent;

    return Consumer(
      builder: (context, ref, _) {
        final themeMode = ref.watch(themeNotifierProvider);
        final theme = Theme.of(context);

        return AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          height: maxExtent,
          decoration: BoxDecoration(
            // Standardized to use .withValues() for consistency
            color: theme.scaffoldBackgroundColor.withValues(alpha: isScrolled ? 0.95 : 1.0),
            boxShadow: isScrolled
                ? [BoxShadow(color: Colors.black.withValues(alpha: 0.05), blurRadius: 8, offset: const Offset(0, 3))]
                : null,
          ),
          padding: EdgeInsets.only(top: topPadding + 4, left: 24, right: 16, bottom: 8),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Text(
                'Krono',
                style: theme.textTheme.headlineLarge?.copyWith(
                  fontWeight: FontWeight.w900,
                  letterSpacing: -1.5,
                  fontSize: 32,
                ),
              ),
              const Spacer(),
              IconButton(
                onPressed: onToggleTheme,
                icon: Icon(
                  themeMode == ThemeMode.light ? Icons.wb_sunny_rounded : Icons.nightlight_round,
                  color: themeMode == ThemeMode.light ? Colors.orange : Colors.indigo[200],
                ),
              ),
              StreakCard(streak: streakCount, activeDates: activeDates),
            ],
          ),
        );
      },
    );
  }

  /// The maximum height of the header, including safe area padding.
  @override
  double get maxExtent => 60 + topPadding;

  /// The minimum height of the header, which is the same as the max height.
  @override
  double get minExtent => 60 + topPadding;

  /// Determines if the header should rebuild when its properties change.
  @override
  bool shouldRebuild(covariant _HeaderDelegate oldDelegate) {
    return oldDelegate.streakCount != streakCount ||
        oldDelegate.topPadding != topPadding ||
        !listEquals(oldDelegate.activeDates, activeDates);
  }
}

lib/src/features/journal/presentation/main_wrapper.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';

import '../../../core/providers/locale_provider.dart';
import '../../../core/providers/notification_provider.dart';
import '../../../core/providers/theme_provider.dart';
import '../../../core/utils/logger_service.dart';

import '../../journal/presentation/add_entry_screen.dart';
import 'home_screen.dart';
import 'settings_screen.dart';
import 'widgets/camera/custom_camera_screen.dart';

/// Manages the state of the bottom navigation bar index.
class NavigationNotifier extends Notifier<int> {
  @override
  int build() => 0;

  /// Updates the currently selected page index.
  void setPage(int index) {
    Logger.info('Navigation changed to page index: $index');
    state = index;
  }
}

/// Provides the current navigation index to the UI.
final navigationProvider = NotifierProvider<NavigationNotifier, int>(NavigationNotifier.new);

/// The main wrapper widget for the application's core screens.
///
/// It handles the bottom navigation dock, screen switching, and global listeners
/// for locale and theme changes. It uses an [IndexedStack] to preserve the state
/// of each screen.
class MainWrapper extends ConsumerWidget {
  /// Creates the main application wrapper.
  const MainWrapper({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationProvider);

    // Listen to theme changes to trigger a rebuild of the dock when switching modes.
    ref.watch(themeNotifierProvider);

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isDark = theme.brightness == Brightness.dark;

    _setupLocaleListener(ref);

    final List<Widget> screens = [
      const HomeScreen(),
      const Center(child: Text("Stats coming soon")), // Placeholder
      const Center(child: Text("Video Recap coming soon")), // Placeholder
      const SettingsScreen(),
    ];

    return Scaffold(
      extendBody: true, // Allows content to flow behind the floating dock.
      body: Stack(
        children: [
          // RepaintBoundary isolates the screen rendering from the dock rendering,
          // improving performance during scrolling or animations.
          RepaintBoundary(
              child: IndexedStack(
                  index: selectedIndex,
                  children: screens
              )
          ),

          _FloatingDock(
              currentIndex: selectedIndex,
              isDark: isDark,
              colorScheme: colorScheme
          ),
        ],
      ),
    );
  }

  /// Sets up a listener to refresh notifications when the app locale changes.
  void _setupLocaleListener(WidgetRef ref) {
    ref.listen(localeProvider, (previous, next) {
      if (previous != null && next != previous) {
        Logger.info('Locale changed from ${previous.languageCode} to ${next.languageCode}. Updating notifications.');
        final notifState = ref.read(notificationProvider);
        if (notifState.isEnabled) {
          ref.read(notificationProvider.notifier).updateSettings(
              true,
              notifState.hour,
              notifState.minute,
              force: true
          );
        }
      }
    });
  }
}

/// A custom floating bottom navigation dock with a "fake glass" effect.
///
/// It uses opacity and gradients to simulate a glass look without the performance
/// cost of a real-time blur filter.
class _FloatingDock extends ConsumerWidget {
  final int currentIndex;
  final bool isDark;
  final ColorScheme colorScheme;

  const _FloatingDock({
    required this.currentIndex,
    required this.isDark,
    required this.colorScheme
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;
    final double dockMarginBottom = systemBottomPadding > 0 ? systemBottomPadding + 20 : 24.0;

    final Color glassBaseColor = colorScheme.surface;
    final double opacity = isDark ? 0.92 : 0.95;

    return Align(
      alignment: Alignment.bottomCenter,
      child: Container(
        margin: EdgeInsets.only(bottom: dockMarginBottom, left: 24, right: 24),
        height: 72,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(36),
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              glassBaseColor.withValues(alpha: opacity),
              glassBaseColor.withValues(alpha: opacity - 0.05),
            ],
          ),
          border: Border.all(
            color: (isDark ? Colors.white : Colors.black).withValues(alpha: 0.12),
            width: 1,
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: isDark ? 0.4 : 0.2),
              blurRadius: 25,
              spreadRadius: -5,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 8),
          child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _DockItem(icon: Icons.grid_view_rounded, isSelected: currentIndex == 0, onTap: () => _handleNav(ref, 0)),

                // Stats button placeholder (commented out as per requirements)
                /*
                _DockItem(icon: Icons.bar_chart_rounded, isSelected: currentIndex == 1, onTap: () => _handleNav(ref, 1)),
                */

                const _AddButton(),

                // Video Recap button placeholder (commented out as per requirements)
                /*
                _DockItem(icon: Icons.movie_filter_rounded, isSelected: currentIndex == 2, onTap: () => _handleNav(ref, 2)),
                */

                _DockItem(icon: Icons.settings_rounded, isSelected: currentIndex == 3, onTap: () => _handleNav(ref, 3)),
              ]
          ),
        ),
      ),
    );
  }

  void _handleNav(WidgetRef ref, int index) {
    HapticFeedback.selectionClick();
    ref.read(navigationProvider.notifier).setPage(index);
  }
}

/// An individual item within the floating dock.
class _DockItem extends StatelessWidget {
  final IconData icon;
  final bool isSelected;
  final VoidCallback onTap;

  const _DockItem({required this.icon, required this.isSelected, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(20),
        splashColor: colorScheme.primary.withValues(alpha: 0.1),
        highlightColor: colorScheme.primary.withValues(alpha: 0.05),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                    icon,
                    color: isSelected ? colorScheme.primary : colorScheme.onSurface.withValues(alpha: 0.5),
                    size: 26
                ),
                const Gap(4),
                AnimatedContainer(
                    duration: const Duration(milliseconds: 200),
                    height: 4,
                    width: 4,
                    decoration: BoxDecoration(
                        color: isSelected ? colorScheme.primary : Colors.transparent,
                        shape: BoxShape.circle
                    )
                ),
              ]
          ),
        ),
      ),
    );
  }
}

/// The central "Add" button in the dock.
///
/// Supports a short tap to open the standard add entry screen, and a long press
/// to quickly launch the camera.
class _AddButton extends StatelessWidget {
  const _AddButton();

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return GestureDetector(
      onTap: () {
        Logger.info('User tapped Add button (standard entry).');
        HapticFeedback.heavyImpact();
        Navigator.push(context, MaterialPageRoute(builder: (_) => const AddEntryScreen()));
      },
      onLongPress: () async {
        Logger.info('User long-pressed Add button (quick camera).');
        HapticFeedback.heavyImpact();

        final String? photoPath = await Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => const CustomCameraScreen()),
        );

        if (photoPath != null && context.mounted) {
          Logger.info('Photo captured via quick camera, navigating to AddEntryScreen.');
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (_) => AddEntryScreen(initialImagePath: photoPath),
            ),
          );
        }
      },
      child: Hero(
        tag: 'add_button_main',
        child: Container(
          height: 56,
          width: 56,
          decoration: BoxDecoration(
            gradient: LinearGradient(
                colors: [colorScheme.primary, colorScheme.primary.withValues(alpha: 0.8)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight
            ),
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                  color: colorScheme.primary.withValues(alpha: 0.4),
                  blurRadius: 15,
                  offset: const Offset(0, 6)
              )
            ],
          ),
          child: const Icon(Icons.add_rounded, color: Colors.white, size: 32),
        ),
      ),
    );
  }
}

lib/src/features/journal/presentation/settings_screen.dart:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';
import 'package:permission_handler/permission_handler.dart';

import '../../../../l10n/app_localizations.dart';
import '../../../core/providers/theme_provider.dart';
import '../../../core/providers/locale_provider.dart';
import '../../../core/providers/auth_provider.dart';
import '../../../core/providers/notification_provider.dart';
import '../../../core/providers/pdf_provider.dart';
import '../../../core/utils/backup_service.dart';
import '../../../core/utils/logger_service.dart';
import '../data/journal_repository.dart';
import '../../../core/utils/notification_service.dart';

import 'widgets/settings_tile.dart';
import 'widgets/settings/settings_section.dart';
import 'widgets/settings/theme_selector_sheet.dart';
import 'widgets/settings/language_selector_sheet.dart';
import 'widgets/settings/time_picker_sheet.dart';

/// The main settings screen of the application.
///
/// Allows users to configure notifications, theme, language, security, and data management.
class SettingsScreen extends ConsumerWidget {
  /// Creates the settings screen.
  const SettingsScreen({super.key});

  /// Returns the localized display name for a given language code.
  String _getLanguageName(String code) {
    return switch (code) {
      'ro' => 'Română',
      'fr' => 'Français',
      'en' => 'English',
      _ => 'English',
    };
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    // Removed unused themeMode variable to fix linter warning.
    final accentColor = ref.watch(accentColorProvider);
    final currentLocale = ref.watch(localeProvider);
    final isAuthEnabled = ref.watch(authSettingsProvider);
    final notifState = ref.watch(notificationProvider);
    final exportPdf = ref.read(exportPdfProvider);

    final String formattedTime =
        "${notifState.hour.toString().padLeft(2, '0')}:${notifState.minute.toString().padLeft(2, '0')}";

    final double systemBottomPadding = MediaQuery.of(context).padding.bottom;
    const double dockHeight = 72.0;
    final double dockMargin = systemBottomPadding > 0 ? systemBottomPadding + 20 : 24.0;
    const double visualBuffer = 16.0;
    final double listBottomPadding = dockHeight + dockMargin + visualBuffer;

    return Scaffold(
      appBar: AppBar(
        title: Text(
            l10n.settings,
            style: const TextStyle(fontWeight: FontWeight.bold)
        ),
        centerTitle: true,
      ),
      body: ListView(
        padding: EdgeInsets.fromLTRB(20, 10, 20, listBottomPadding),
        physics: const BouncingScrollPhysics(),
        children: [
          SettingsSection(
            title: l10n.notifications,
            children: [
              SettingsTile(
                icon: Icons.notifications_active_outlined,
                title: l10n.dailyReminder,
                subtitle: notifState.isEnabled
                    ? "${l10n.reminderSubtitle} ($formattedTime)"
                    : l10n.reminderSubtitle,
                onTap: () {
                  if (notifState.isEnabled) {
                    _openModal(context, const TimePickerSheet());
                  } else {
                    _handleToggleNotifications(context, ref, true);
                  }
                },
                trailing: Switch.adaptive(
                  value: notifState.isEnabled,
                  activeThumbColor: accentColor,
                  activeTrackColor: accentColor.withValues(alpha: 0.4),
                  onChanged: (val) => _handleToggleNotifications(context, ref, val),
                ),
              ),
            ],
          ),
          const Gap(24),
          SettingsSection(
            title: l10n.personalization,
            children: [
              SettingsTile(
                icon: Icons.palette_outlined,
                title: l10n.appTheme,
                subtitle: l10n.chooseAccent,
                trailing: CircleAvatar(radius: 10, backgroundColor: accentColor),
                onTap: () => _openModal(context, const ThemeSelector()),
              ),
              SettingsTile(
                icon: Icons.language_rounded,
                title: l10n.language,
                subtitle: _getLanguageName(currentLocale.languageCode),
                onTap: () => _openModal(context, const LanguageSelector()),
              ),
              SettingsTile(
                icon: Icons.dark_mode_outlined,
                title: l10n.darkMode,
                onTap: () {
                  HapticFeedback.lightImpact();
                  ref.read(themeNotifierProvider.notifier).toggleTheme();
                },
                trailing: Switch.adaptive(
                  value: Theme.of(context).brightness == Brightness.dark,
                  activeThumbColor: accentColor,
                  activeTrackColor: accentColor.withValues(alpha: 0.4),
                  onChanged: (_) {
                    HapticFeedback.lightImpact();
                    ref.read(themeNotifierProvider.notifier).toggleTheme();
                  },
                ),
              ),
            ],
          ),
          const Gap(24),
          SettingsSection(
            title: l10n.dataBackup,
            children: [
              SettingsTile(
                icon: Icons.cloud_upload_outlined,
                title: l10n.exportBackup,
                onTap: () => _handleExportWithLoading(context, ref, l10n),
              ),
              SettingsTile(
                icon: Icons.cloud_download_outlined,
                title: l10n.importBackup,
                onTap: () => _handleImportBackup(context, ref, l10n),
              ),
              SettingsTile(
                icon: Icons.picture_as_pdf_outlined,
                title: l10n.exportPdf,
                onTap: () async {
                  Logger.info('User initiated PDF export.');
                  HapticFeedback.mediumImpact();
                  await exportPdf();
                },
              ),
            ],
          ),
          const Gap(24),
          SettingsSection(
            title: l10n.info,
            children: [
              SettingsTile(
                icon: Icons.fingerprint_rounded,
                title: l10n.appLock,
                subtitle: l10n.biometrics,
                onTap: () => _handleToggleAuth(context, ref, !isAuthEnabled),
                trailing: Switch.adaptive(
                  value: isAuthEnabled,
                  activeThumbColor: accentColor,
                  activeTrackColor: accentColor.withValues(alpha: 0.4),
                  onChanged: (val) => _handleToggleAuth(context, ref, val),
                ),
              ),
              SettingsTile(
                icon: Icons.info_outline_rounded,
                title: l10n.aboutKrono,
                onTap: () => _showAboutDialog(context, l10n),
              ),
            ],
          ),
          const Gap(24),
          SettingsSection(
            title: l10n.dangerZone,
            children: [
              SettingsTile(
                icon: Icons.delete_forever_outlined,
                iconColor: Colors.redAccent,
                title: l10n.deleteAll,
                onTap: () => _showDeleteDialog(context, ref, l10n),
              ),
            ],
          ),
          const Gap(48),
          _Footer(l10n: l10n),
        ],
      ),
    );
  }

  /// Orchestrates the backup export sequence with user feedback.
  ///
  /// Displays a non-blocking loading overlay during archive preparation,
  /// triggers the native OS save dialog, and provides haptic/visual confirmation upon completion.
  Future<void> _handleExportWithLoading(BuildContext context, WidgetRef ref, AppLocalizations l10n) async {
    Logger.info('Starting backup export process.');
    HapticFeedback.mediumImpact();

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => _LoadingDialog(
        title: l10n.exportBackup,
        message: l10n.exportingMessage,
      ),
    );

    bool success = false;
    try {
      success = await ref.read(backupServiceProvider).exportFullBackup(l10n);
      Logger.info('Backup export completed. Success: $success');
    } catch (e, stack) {
      Logger.error('Export process exception.', e, stack);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(l10n.backupExportError),
            backgroundColor: Theme.of(context).colorScheme.error,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } finally {
      if (context.mounted) {
        Navigator.of(context, rootNavigator: true).pop();
      }

      if (success && context.mounted) {
        HapticFeedback.heavyImpact();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                const Icon(Icons.check_circle_outline_rounded, color: Colors.white),
                const Gap(12),
                Expanded(child: Text(l10n.backupExportedSuccess)),
              ],
            ),
            backgroundColor: Colors.green.shade800,
            behavior: SnackBarBehavior.floating,
            duration: const Duration(seconds: 4),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      } else if (!success && context.mounted) {
        HapticFeedback.lightImpact();
      }
    }
  }

  /// Opens a modal bottom sheet with the provided child widget.
  void _openModal(BuildContext context, Widget child) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => child,
    );
  }

  /// Coordinates the import process with a non-blocking UI overlay.
  Future<void> _handleImportBackup(BuildContext context, WidgetRef ref, AppLocalizations l10n) async {
    Logger.info('Starting backup import process.');
    HapticFeedback.mediumImpact();

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => _LoadingDialog(
        title: l10n.importBackup,
        message: l10n.processing,
      ),
    );

    bool success = false;
    try {
      success = await ref.read(backupServiceProvider).importFullBackup();
      Logger.info('Backup import completed. Success: $success');
    } catch (e, stack) {
      Logger.error('Settings import handler error.', e, stack);
    } finally {
      if (context.mounted) {
        Navigator.of(context, rootNavigator: true).pop();
      }

      if (success && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(l10n.backupRestored),
            backgroundColor: Colors.green.shade800,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  /// Handles the notification toggle with Android 14 permission checks.
  Future<void> _handleToggleNotifications(BuildContext context, WidgetRef ref, bool newValue) async {
    Logger.info('Toggling notifications to: $newValue');
    HapticFeedback.lightImpact();
    final l10n = AppLocalizations.of(context)!;
    final service = ref.read(notificationServiceProvider);

    if (newValue) {
      final granted = await service.requestPermission();

      if (granted) {
        final bool isExactPermitted = await service.canScheduleExactAlarms();

        final state = ref.read(notificationProvider);
        await ref.read(notificationProvider.notifier).updateSettings(true, state.hour, state.minute);

        if (!isExactPermitted && context.mounted) {
          Logger.warning('Exact alarm permission missing. Showing dialog.');
          _showExactAlarmDialog(context, ref, l10n);
        } else if (context.mounted) {
          _openModal(context, const TimePickerSheet());
        }
      } else if (context.mounted) {
        Logger.warning('Notification permission denied.');
        _showPermissionDeniedDialog(context, l10n);
      }
    } else {
      final state = ref.read(notificationProvider);
      await ref.read(notificationProvider.notifier)
          .updateSettings(false, state.hour, state.minute);
    }
  }

  /// Explains the need for exact alarms as per Google Play policy.
  void _showExactAlarmDialog(BuildContext context, WidgetRef ref, AppLocalizations l10n) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: const Text("Precise Reminders"),
        content: const Text("To receive reminders at the exact time you set, Krono needs the 'Alarms & Reminders' permission. Please enable it in the next screen."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(l10n.cancel)),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(context);
              await ref.read(notificationServiceProvider).openExactAlarmSettings();
            },
            child: const Text("Allow"),
          ),
        ],
      ),
    );
  }

  /// Toggles biometric authentication, guiding the user if security is not set up.
  Future<void> _handleToggleAuth(BuildContext context, WidgetRef ref, bool newValue) async {
    Logger.info('Toggling app lock to: $newValue');
    HapticFeedback.lightImpact();
    final l10n = AppLocalizations.of(context)!;
    final authService = ref.read(authServiceProvider);

    // Verify hardware and enrollment before attempting authentication
    final bool canAuth = await authService.canAuthenticate();

    if (!canAuth) {
      Logger.warning('Authentication toggle aborted: Device not capable.');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(l10n.securityNotSetup),
            backgroundColor: Theme.of(context).colorScheme.error,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
      return;
    }

    final success = await authService.authenticate(
      newValue ? l10n.authReasonToggleOn : l10n.authReasonToggleOff,
    );

    if (success) {
      await ref.read(authSettingsProvider.notifier).toggleAuth(newValue);
    } else {
      Logger.warning('Authentication failed during toggle.');
      HapticFeedback.vibrate();
    }
  }

  /// Shows a confirmation dialog for deleting all app data.
  void _showDeleteDialog(BuildContext context, WidgetRef ref, AppLocalizations l10n) {
    Logger.info('Delete all data dialog opened.');
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.confirmDeleteTitle, style: const TextStyle(fontWeight: FontWeight.bold)),
        content: Text(l10n.confirmDeleteContent),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(l10n.cancel)),
          TextButton(
            onPressed: () async {
              Logger.info('User confirmed deletion of all data.');
              Navigator.pop(context);
              await ref.read(journalRepositoryProvider).deleteAllData();
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(l10n.deleteAllSuccess), backgroundColor: Colors.redAccent),
                );
              }
            },
            child: Text(l10n.delete, style: const TextStyle(color: Colors.red, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
    );
  }

  /// Shows a dialog when notification permissions are denied, guiding the user to settings.
  void _showPermissionDeniedDialog(BuildContext context, AppLocalizations l10n) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(l10n.notificationsDeniedTitle),
        content: Text(l10n.notificationsDeniedContent),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(l10n.cancel)),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              openAppSettings();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.primary,
              foregroundColor: Theme.of(context).colorScheme.onPrimary,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
            child: Text(l10n.openSettings),
          ),
        ],
      ),
    );
  }

  /// Shows the "About" dialog with app information.
  void _showAboutDialog(BuildContext context, AppLocalizations l10n) {
    showAboutDialog(
      context: context,
      applicationName: 'Krono',
      applicationVersion: '1.0.0',
      applicationLegalese: l10n.copyright,
      children: [
        const Gap(16),
        Text(l10n.aboutKronoDetail),
      ],
    );
  }
}

/// A footer widget displaying the app name and version.
class _Footer extends StatelessWidget {
  final AppLocalizations l10n;
  const _Footer({required this.l10n});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        children: [
          Text(l10n.appTitle,
              style: const TextStyle(fontWeight: FontWeight.w900, fontSize: 18, letterSpacing: -0.5)),
          const Gap(4),
          Text('${l10n.version} 1.0.0',
              style: TextStyle(color: Colors.grey.shade500, fontSize: 12)),
        ],
      ),
    );
  }
}

/// A non-dismissible loading dialog with a spinner and message.
class _LoadingDialog extends StatelessWidget {
  final String title;
  final String message;

  const _LoadingDialog({required this.title, required this.message});

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false,
      child: Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        elevation: 10,
        backgroundColor: Theme.of(context).colorScheme.surface,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 32, horizontal: 24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const RepaintBoundary(
                child: SizedBox(
                  height: 50, width: 50,
                  child: CircularProgressIndicator(strokeWidth: 3),
                ),
              ),
              const Gap(24),
              Text(
                title,
                style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
              const Gap(8),
              Text(
                message,
                style: TextStyle(color: Theme.of(context).colorScheme.onSurfaceVariant, fontSize: 14),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

lib/main.dart:
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:krono/src/core/utils/thumbnail/thumbnail_migration.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_native_splash/flutter_native_splash.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

// --- FIREBASE IMPORTS ---
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'firebase_options.dart';

// --- LOCAL IMPORTS ---
import 'l10n/app_localizations.dart';
import 'src/core/bootstrap/cleanup_runner.dart';
import 'src/core/database/database.dart';
import 'src/core/providers/locale_provider.dart';
import 'src/core/providers/theme_provider.dart';
import 'src/core/utils/activity_sync.dart';
import 'src/core/utils/auth_wrapper.dart';
import 'src/core/utils/backup_service.dart';
import 'src/core/utils/logger_service.dart';
import 'src/core/utils/notification_service.dart';
import 'src/core/utils/theme.dart';
import 'src/features/journal/presentation/main_wrapper.dart';

/// Initializes locale date formatting data for supported languages.
///
/// This ensures that date formatting functions (e.g., from `intl` package)
/// work correctly for Romanian, English, and French before the UI renders.
Future<void> _initializeDateFormatting() async {
  final locales = ['ro', 'en', 'fr'];
  await Future.wait(locales.map((locale) => initializeDateFormatting(locale, null)));
}

/// The application entry point.
///
/// Sets up the execution zone to catch global errors, initializes critical
/// services (Firebase, Database, Preferences) in parallel for performance,
/// and schedules non-critical background tasks to run after the UI is visible.
void main() async {
  runZonedGuarded<Future<void>>(() async {
    // 1. Mandatory minimal initialization
    final widgetsBinding = WidgetsFlutterBinding.ensureInitialized();
    FlutterNativeSplash.preserve(widgetsBinding: widgetsBinding);

    // 2. Load critical resources in parallel to minimize startup time
    Logger.info('Bootstrap: Initializing critical resources...');
    final initResults = await Future.wait([
      SharedPreferences.getInstance(), // Index 0
      Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform), // Index 1
      _initializeDateFormatting(), // Index 2
    ]);

    final prefs = initResults[0] as SharedPreferences;

    // 3. Configure core services
    // Pass all uncaught Flutter errors to Crashlytics
    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

    final database = AppDatabase();
    final notificationService = NotificationService(FlutterLocalNotificationsPlugin());
    await notificationService.init();

    // Optimize Image Cache for list performance
    PaintingBinding.instance.imageCache.maximumSize = 50;
    PaintingBinding.instance.imageCache.maximumSizeBytes = 100 << 20; // 100 MB

    Logger.info('Bootstrap: Services initialized. Launching UI.');

    // 4. Launch the application
    runApp(
      ProviderScope(
        overrides: [
          sharedPreferencesProvider.overrideWithValue(prefs),
          databaseProvider.overrideWithValue(database),
          notificationServiceProvider.overrideWithValue(notificationService),
        ],
        child: const KronoApp(),
      ),
    );

    // 5. Deferred Tasks
    // These operations run in the background after the first frame is rendered
    // to prevent blocking the main thread during startup.
    Future.microtask(() async {
      Logger.info('Bootstrap: Starting deferred background tasks.');
      try {
        if (FirebaseAuth.instance.currentUser == null) {
          Logger.info('Auth: Signing in anonymously.');
          await FirebaseAuth.instance.signInAnonymously();
        }

        await syncActivityLogFromEntries(database);
        await runBackgroundThumbnailMigration(database, concurrency: 3);
        await runCleanupIfNeeded(db: database, prefs: prefs);
        await BackupService.cleanupCache();
        Logger.info('Bootstrap: Deferred tasks completed successfully.');
      } catch (e, stack) {
        Logger.error('Bootstrap: Error during deferred tasks.', e, stack);
      }
    });

    // 6. Remove Splash Screen once the UI is stable
    Future.delayed(const Duration(milliseconds: 200), () {
      FlutterNativeSplash.remove();
    });

  }, (error, stack) {
    // Catch any errors that occur outside the Flutter context (Zone errors)
    Logger.error('Global: Uncaught error in runZonedGuarded.', error, stack);
  });
}

/// The root widget of the application.
///
/// Configures global application settings including:
/// - Routing (via [MainWrapper])
/// - Theming (Light/Dark mode)
/// - Localization
/// - Authentication state wrapping
class KronoApp extends ConsumerWidget {
  const KronoApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeNotifierProvider);
    final accentColor = ref.watch(accentColorProvider);
    final currentLocale = ref.watch(localeProvider);
    final analytics = FirebaseAnalytics.instance;

    return MaterialApp(
      title: 'Krono',
      debugShowCheckedModeBanner: false,
      locale: currentLocale,
      localizationsDelegates: AppLocalizations.localizationsDelegates,
      supportedLocales: AppLocalizations.supportedLocales,
      theme: AppTheme.createLightTheme(accentColor),
      darkTheme: AppTheme.createDarkTheme(accentColor),
      themeMode: themeMode,
      navigatorObservers: [
        FirebaseAnalyticsObserver(analytics: analytics),
      ],
      home: const AuthWrapper(
        child: MainWrapper(),
      ),
    );
  }
}